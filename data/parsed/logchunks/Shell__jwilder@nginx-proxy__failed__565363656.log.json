{
  "log_path": "Shell/jwilder@nginx-proxy/failed/565363656.log",
  "failure_chunk": "[1m[31m__________________________ test_unknown_virtual_host ___________________________[0m\n\ndocker_compose = docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = conftest.requests_for_docker object at 0x7f9a96f34f10>\n\n[1m    def test_unknown_virtual_host(docker_compose, nginxproxy):[0m\n[1m>       r = nginxproxy.get(\"http://nginx-proxy/port\")[0m\n\n[1m[31mtest_DOCKER_HOST_unix_socket.py[0m:4: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[1m[31mconftest.py[0m:83: in get\n[1m    return _get(*args, **kwargs)[0m\n[1m[31m/usr/local/lib/python2.7/site-packages/backoff.py[0m:173: in retry\n[1m    ret = target(*args, **kwargs)[0m\n[1m[31mconftest.py[0m:82: in _get\n[1m    return self.session.get(*args, **kwargs)[0m\n[1m[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py[0m:488: in get\n[1m    return self.request('GET', url, **kwargs)[0m\n[1m[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py[0m:475: in request\n[1m    resp = self.send(prep, **send_kwargs)[0m\n[1m[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py[0m:596: in send\n[1m    r = adapter.send(request, **kwargs)[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = requests.adapters.HTTPAdapter object at 0x7f9a96f66390>\nrequest = PreparedRequest [GET]>, stream = False\ntimeout = requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96f66b50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m\n[1m        \"\"\"Sends PreparedRequest object. Returns Response object.[0m\n[1m    [0m\n[1m            :param request: The :class:`PreparedRequest PreparedRequest>` being sent.[0m\n[1m            :param stream: (optional) Whether to stream the request content.[0m\n[1m            :param timeout: (optional) How long to wait for the server to send[0m\n[1m                data before giving up, as a float, or a :ref:`(connect timeout,[0m\n[1m                read timeout) timeouts>` tuple.[0m\n[1m            :type timeout: float or tuple[0m\n[1m            :param verify: (optional) Whether to verify SSL certificates.[0m\n[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.[0m\n[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m\n[1m            :rtype: requests.Response[0m\n[1m            \"\"\"[0m\n[1m    [0m\n[1m        conn = self.get_connection(request.url, proxies)[0m\n[1m    [0m\n[1m        self.cert_verify(conn, request.url, verify, cert)[0m\n[1m        url = self.request_url(request, proxies)[0m\n[1m        self.add_headers(request)[0m\n[1m    [0m\n[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m\n[1m    [0m\n[1m        if isinstance(timeout, tuple):[0m\n[1m            try:[0m\n[1m                connect, read = timeout[0m\n[1m                timeout = TimeoutSauce(connect=connect, read=read)[0m\n[1m            except ValueError as e:[0m\n[1m                # this may raise a string formatting error.[0m\n[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"[0m\n[1m                       \"timeout tuple, or a single float to set \"[0m\n[1m                       \"both timeouts to the same value\".format(timeout))[0m\n[1m                raise ValueError(err)[0m\n[1m        else:[0m\n[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)[0m\n[1m    [0m\n[1m        try:[0m\n[1m            if not chunked:[0m\n[1m                resp = conn.urlopen([0m\n[1m                    method=request.method,[0m\n[1m                    url=url,[0m\n[1m                    body=request.body,[0m\n[1m                    headers=request.headers,[0m\n[1m                    redirect=False,[0m\n[1m                    assert_same_host=False,[0m\n[1m                    preload_content=False,[0m\n[1m                    decode_content=False,[0m\n[1m                    retries=self.max_retries,[0m\n[1m                    timeout=timeout[0m\n[1m                )[0m\n[1m    [0m\n[1m            # Send the request.[0m\n[1m            else:[0m\n[1m                if hasattr(conn, 'proxy_pool'):[0m\n[1m                    conn = conn.proxy_pool[0m\n[1m    [0m\n[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)[0m\n[1m    [0m\n[1m                try:[0m\n[1m                    low_conn.putrequest(request.method,[0m\n[1m                                        url,[0m\n[1m                                        skip_accept_encoding=True)[0m\n[1m    [0m\n[1m                    for header, value in request.headers.items():[0m\n[1m                        low_conn.putheader(header, value)[0m\n[1m    [0m\n[1m                    low_conn.endheaders()[0m\n[1m    [0m\n[1m                    for i in request.body:[0m\n[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))[0m\n[1m                        low_conn.send(b'\\r\\n')[0m\n[1m                        low_conn.send(i)[0m\n[1m                        low_conn.send(b'\\r\\n')[0m\n[1m                    low_conn.send(b'0\\r\\n\\r\\n')[0m\n[1m    [0m\n[1m                    # Receive the response from the server[0m\n[1m                    try:[0m\n[1m                        # For Python 2.7+ versions, use buffering of HTTP[0m\n[1m                        # responses[0m\n[1m                        r = low_conn.getresponse(buffering=True)[0m\n[1m                    except TypeError:[0m\n[1m                        # For compatibility with Python 2.6 versions and back[0m\n[1m                        r = low_conn.getresponse()[0m\n[1m    [0m\n[1m                    resp = HTTPResponse.from_httplib([0m\n[1m                        r,[0m\n[1m                        pool=conn,[0m\n[1m                        connection=low_conn,[0m\n[1m                        preload_content=False,[0m\n[1m                        decode_content=False[0m\n[1m                    )[0m\n[1m                except:[0m\n[1m                    # If we hit any problems here, clean up the connection.[0m\n[1m                    # Then, reraise so that we can handle the actual exception.[0m\n[1m                    low_conn.close()[0m\n[1m                    raise[0m\n[1m    [0m\n[1m        except (ProtocolError, socket.error) as err:[0m\n[1m            raise ConnectionError(err, request=request)[0m\n[1m    [0m\n[1m        except MaxRetryError as e:[0m\n[1m            if isinstance(e.reason, ConnectTimeoutError):[0m\n[1m                # TODO: Remove this in 3.0.0: see #2811[0m\n[1m                if not isinstance(e.reason, NewConnectionError):[0m\n[1m                    raise ConnectTimeout(e, request=request)[0m\n[1m    [0m\n[1m            if isinstance(e.reason, ResponseError):[0m\n[1m                raise RetryError(e, request=request)[0m\n[1m    [0m\n[1m            if isinstance(e.reason, _ProxyError):[0m\n[1m                raise ProxyError(e, request=request)[0m\n[1m    [0m\n[1m>           raise ConnectionError(e, request=request)[0m\n[1m[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96f4b610>: Failed to establish a new connection: [Errno -2] Name does not resolve',))[0m\n\n[1m[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py[0m:487: ConnectionError",
  "keywords": [
    "FAILURES",
    "===================================",
    "Error"
  ],
  "category": "0",
  "full_log": "travis_fold:start:worker_info\n\u001b[0K\u001b[33;1mWorker information\u001b[0m\nhostname: 74277ab9-36af-48db-b090-301eb577a3d4@1.worker-org-b6c9dcb4d-2t5gd.gce-production-1\nversion: v6.2.1 https://github.com/travis-ci/worker/tree/4e3246c044eb4915c2378ffacd0b3d3ed0136bba\ninstance: travis-job-f6734fb8-99bc-4819-8822-be8aa6f6f806 travis-ci-garnet-trusty-1512502259-986baf0 (via amqp)\nstartup: 6.263058467s\ntravis_fold:end:worker_info\n\u001b[0Ktravis_fold:start:system_info\n\u001b[0K\u001b[33;1mBuild system information\u001b[0m\nBuild language: ruby\nBuild group: stable\nBuild dist: trusty\nBuild id: 565363656\nJob id: 565363658\nRuntime kernel version: 4.4.0-101-generic\ntravis-build version: 24c88d12b\n\u001b[34m\u001b[1mBuild image provisioning date and time\u001b[0m\nTue Dec  5 19:58:13 UTC 2017\n\u001b[34m\u001b[1mOperating System Details\u001b[0m\nDistributor ID:\tUbuntu\nDescription:\tUbuntu 14.04.5 LTS\nRelease:\t14.04\nCodename:\ttrusty\n\u001b[34m\u001b[1mCookbooks Version\u001b[0m\n7c2c6a6 https://github.com/travis-ci/travis-cookbooks/tree/7c2c6a6\n\u001b[34m\u001b[1mgit version\u001b[0m\ngit version 2.15.1\n\u001b[34m\u001b[1mbash version\u001b[0m\nGNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu)\n\u001b[34m\u001b[1mgcc version\u001b[0m\ngcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4\nCopyright (C) 2013 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n\u001b[34m\u001b[1mdocker version\u001b[0m\nClient:\n Version:      17.09.0-ce\n API version:  1.32\n Go version:   go1.8.3\n Git commit:   afdb6d4\n Built:        Tue Sep 26 22:42:38 2017\n OS/Arch:      linux/amd64\n\nServer:\n Version:      17.09.0-ce\n API version:  1.32 (minimum version 1.12)\n Go version:   go1.8.3\n Git commit:   afdb6d4\n Built:        Tue Sep 26 22:41:20 2017\n OS/Arch:      linux/amd64\n Experimental: false\n\u001b[34m\u001b[1mclang version\u001b[0m\nclang version 5.0.0 (tags/RELEASE_500/final)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\nInstalledDir: /usr/local/clang-5.0.0/bin\n\u001b[34m\u001b[1mjq version\u001b[0m\njq-1.5\n\u001b[34m\u001b[1mbats version\u001b[0m\nBats 0.4.0\n\u001b[34m\u001b[1mshellcheck version\u001b[0m\n0.4.6\n\u001b[34m\u001b[1mshfmt version\u001b[0m\nv2.0.0\n\u001b[34m\u001b[1mccache version\u001b[0m\nccache version 3.1.9\n\nCopyright (C) 2002-2007 Andrew Tridgell\nCopyright (C) 2009-2011 Joel Rosdahl\n\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free Software\nFoundation; either version 3 of the License, or (at your option) any later\nversion.\n\u001b[34m\u001b[1mcmake version\u001b[0m\ncmake version 3.9.2\n\nCMake suite maintained and supported by Kitware (kitware.com/cmake).\n\u001b[34m\u001b[1mheroku version\u001b[0m\nheroku-cli/6.14.39-addc925 (linux-x64) node-v9.2.0\n\u001b[34m\u001b[1mimagemagick version\u001b[0m\nVersion: ImageMagick 6.7.7-10 2017-07-31 Q16 http://www.imagemagick.org\n\u001b[34m\u001b[1mmd5deep version\u001b[0m\n4.2\n\u001b[34m\u001b[1mmercurial version\u001b[0m\nMercurial Distributed SCM (version 4.2.2)\n(see https://mercurial-scm.org for more information)\n\nCopyright (C) 2005-2017 Matt Mackall and others\nThis is free software; see the source for copying conditions. There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\u001b[34m\u001b[1mmysql version\u001b[0m\nmysql  Ver 14.14 Distrib 5.6.33, for debian-linux-gnu (x86_64) using  EditLine wrapper\n\u001b[34m\u001b[1mopenssl version\u001b[0m\nOpenSSL 1.0.1f 6 Jan 2014\n\u001b[34m\u001b[1mpacker version\u001b[0m\nPacker v1.0.2\n\nYour version of Packer is out of date! The latest version\nis 1.1.2. You can update by downloading from www.packer.io\n\u001b[34m\u001b[1mpostgresql client version\u001b[0m\npsql (PostgreSQL) 9.6.6\n\u001b[34m\u001b[1mragel version\u001b[0m\nRagel State Machine Compiler version 6.8 Feb 2013\nCopyright (c) 2001-2009 by Adrian Thurston\n\u001b[34m\u001b[1msubversion version\u001b[0m\nsvn, version 1.8.8 (r1568071)\n   compiled Aug 10 2017, 17:20:39 on x86_64-pc-linux-gnu\n\nCopyright (C) 2013 The Apache Software Foundation.\nThis software consists of contributions made by many people;\nsee the NOTICE file for more information.\nSubversion is open source software, see http://subversion.apache.org/\n\nThe following repository access (RA) modules are available:\n\n* ra_svn : Module for accessing a repository using the svn network protocol.\n  - with Cyrus SASL authentication\n  - handles 'svn' scheme\n* ra_local : Module for accessing a repository on local disk.\n  - handles 'file' scheme\n* ra_serf : Module for accessing a repository via WebDAV protocol using serf.\n  - using serf 1.3.3\n  - handles 'http' scheme\n  - handles 'https' scheme\n\n\u001b[34m\u001b[1msudo version\u001b[0m\nSudo version 1.8.9p5\nConfigure options: --prefix=/usr -v --with-all-insults --with-pam --with-fqdn --with-logging=syslog --with-logfac=authpriv --with-env-editor --with-editor=/usr/bin/editor --with-timeout=15 --with-password-timeout=0 --with-passprompt=[sudo] password for %p:  --without-lecture --with-tty-tickets --disable-root-mailer --enable-admin-flag --with-sendmail=/usr/sbin/sendmail --with-timedir=/var/lib/sudo --mandir=/usr/share/man --libexecdir=/usr/lib/sudo --with-sssd --with-sssd-lib=/usr/lib/x86_64-linux-gnu --with-selinux\nSudoers policy plugin version 1.8.9p5\nSudoers file grammar version 43\n\nSudoers path: /etc/sudoers\nAuthentication methods: 'pam'\nSyslog facility if syslog is being used for logging: authpriv\nSyslog priority to use when user authenticates successfully: notice\nSyslog priority to use when user authenticates unsuccessfully: alert\nSend mail if the user is not in sudoers\nUse a separate timestamp for each user/tty combo\nLecture user the first time they run sudo\nRoot may run sudo\nAllow some information gathering to give useful error messages\nRequire fully-qualified hostnames in the sudoers file\nVisudo will honor the EDITOR environment variable\nSet the LOGNAME and USER environment variables\nLength at which to wrap log file lines (0 for no wrap): 80\nAuthentication timestamp timeout: 15.0 minutes\nPassword prompt timeout: 0.0 minutes\nNumber of tries to enter a password: 3\nUmask to use or 0777 to use user's: 022\nPath to mail program: /usr/sbin/sendmail\nFlags for mail program: -t\nAddress to send mail to: root\nSubject line for mail messages: *** SECURITY information for %h ***\nIncorrect password message: Sorry, try again.\nPath to authentication timestamp dir: /var/lib/sudo\nDefault password prompt: [sudo] password for %p: \nDefault user to run commands as: root\nValue to override user's $PATH with: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin\nPath to the editor for use by visudo: /usr/bin/editor\nWhen to require a password for 'list' pseudocommand: any\nWhen to require a password for 'verify' pseudocommand: all\nFile descriptors >= 3 will be closed before executing a command\nEnvironment variables to check for sanity:\n\tTZ\n\tTERM\n\tLINGUAS\n\tLC_*\n\tLANGUAGE\n\tLANG\n\tCOLORTERM\nEnvironment variables to remove:\n\tRUBYOPT\n\tRUBYLIB\n\tPYTHONUSERBASE\n\tPYTHONINSPECT\n\tPYTHONPATH\n\tPYTHONHOME\n\tTMPPREFIX\n\tZDOTDIR\n\tREADNULLCMD\n\tNULLCMD\n\tFPATH\n\tPERL5DB\n\tPERL5OPT\n\tPERL5LIB\n\tPERLLIB\n\tPERLIO_DEBUG \n\tJAVA_TOOL_OPTIONS\n\tSHELLOPTS\n\tGLOBIGNORE\n\tPS4\n\tBASH_ENV\n\tENV\n\tTERMCAP\n\tTERMPATH\n\tTERMINFO_DIRS\n\tTERMINFO\n\t_RLD*\n\tLD_*\n\tPATH_LOCALE\n\tNLSPATH\n\tHOSTALIASES\n\tRES_OPTIONS\n\tLOCALDOMAIN\n\tCDPATH\n\tIFS\nEnvironment variables to preserve:\n\tJAVA_HOME\n\tTRAVIS\n\tCI\n\tDEBIAN_FRONTEND\n\tXAUTHORIZATION\n\tXAUTHORITY\n\tPS2\n\tPS1\n\tPATH\n\tLS_COLORS\n\tKRB5CCNAME\n\tHOSTNAME\n\tHOME\n\tDISPLAY\n\tCOLORS\nLocale to use while parsing sudoers: C\nDirectory in which to store input/output logs: /var/log/sudo-io\nFile in which to store the input/output log: %{seq}\nAdd an entry to the utmp/utmpx file when allocating a pty\nPAM service name to use\nPAM service name to use for login shells\nCreate a new PAM session for the command to run in\nMaximum I/O log sequence number: 0\n\nLocal IP address and netmask pairs:\n\t10.240.0.28/255.255.255.255\n\t172.17.0.1/255.255.0.0\n\nSudoers I/O plugin version 1.8.9p5\n\u001b[34m\u001b[1mgzip version\u001b[0m\ngzip 1.6\nCopyright (C) 2007, 2010, 2011 Free Software Foundation, Inc.\nCopyright (C) 1993 Jean-loup Gailly.\nThis is free software.  You may redistribute copies of it under the terms of\nthe GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\nThere is NO WARRANTY, to the extent permitted by law.\n\nWritten by Jean-loup Gailly.\n\u001b[34m\u001b[1mzip version\u001b[0m\nCopyright (c) 1990-2008 Info-ZIP - Type 'zip \"-L\"' for software license.\nThis is Zip 3.0 (July 5th 2008), by Info-ZIP.\nCurrently maintained by E. Gordon.  Please send bug reports to\nthe authors using the web page at www.info-zip.org; see README for details.\n\nLatest sources and executables are at ftp://ftp.info-zip.org/pub/infozip,\nas of above date; see http://www.info-zip.org/ for other sites.\n\nCompiled with gcc 4.8.2 for Unix (Linux ELF) on Oct 21 2013.\n\nZip special compilation options:\n\tUSE_EF_UT_TIME       (store Universal Time)\n\tBZIP2_SUPPORT        (bzip2 library version 1.0.6, 6-Sept-2010)\n\t    bzip2 code and library copyright (c) Julian R Seward\n\t    (See the bzip2 license for terms of use)\n\tSYMLINK_SUPPORT      (symbolic links supported)\n\tLARGE_FILE_SUPPORT   (can read and write large files on file system)\n\tZIP64_SUPPORT        (use Zip64 to store large files in archives)\n\tUNICODE_SUPPORT      (store and read UTF-8 Unicode paths)\n\tSTORE_UNIX_UIDs_GIDs (store UID/GID sizes/values using new extra field)\n\tUIDGID_NOT_16BIT     (old Unix 16-bit UID/GID extra field not used)\n\t[encryption, version 2.91 of 05 Jan 2007] (modified for Zip 3)\n\nEncryption notice:\n\tThe encryption code of this program is not copyrighted and is\n\tput in the public domain.  It was originally written in Europe\n\tand, to the best of our knowledge, can be freely distributed\n\tin both source and object forms from any country, including\n\tthe USA under License Exception TSU of the U.S. Export\n\tAdministration Regulations (section 740.13(e)) of 6 June 2002.\n\nZip environment options:\n             ZIP:  [none]\n          ZIPOPT:  [none]\n\u001b[34m\u001b[1mvim version\u001b[0m\nVIM - Vi IMproved 7.4 (2013 Aug 10, compiled Nov 24 2016 16:43:18)\nIncluded patches: 1-52\nExtra patches: 8.0.0056\nModified by pkg-vim-maintainers@lists.alioth.debian.org\nCompiled by buildd@\nHuge version without GUI.  Features included (+) or not (-):\n+acl             +farsi           +mouse_netterm   +syntax\n+arabic          +file_in_path    +mouse_sgr       +tag_binary\n+autocmd         +find_in_path    -mouse_sysmouse  +tag_old_static\n-balloon_eval    +float           +mouse_urxvt     -tag_any_white\n-browse          +folding         +mouse_xterm     -tcl\n++builtin_terms  -footer          +multi_byte      +terminfo\n+byte_offset     +fork()          +multi_lang      +termresponse\n+cindent         +gettext         -mzscheme        +textobjects\n-clientserver    -hangul_input    +netbeans_intg   +title\n-clipboard       +iconv           +path_extra      -toolbar\n+cmdline_compl   +insert_expand   -perl            +user_commands\n+cmdline_hist    +jumplist        +persistent_undo +vertsplit\n+cmdline_info    +keymap          +postscript      +virtualedit\n+comments        +langmap         +printer         +visual\n+conceal         +libcall         +profile         +visualextra\n+cryptv          +linebreak       +python          +viminfo\n+cscope          +lispindent      -python3         +vreplace\n+cursorbind      +listcmds        +quickfix        +wildignore\n+cursorshape     +localmap        +reltime         +wildmenu\n+dialog_con      -lua             +rightleft       +windows\n+diff            +menu            -ruby            +writebackup\n+digraphs        +mksession       +scrollbind      -X11\n-dnd             +modify_fname    +signs           -xfontset\n-ebcdic          +mouse           +smartindent     -xim\n+emacs_tags      -mouseshape      -sniff           -xsmp\n+eval            +mouse_dec       +startuptime     -xterm_clipboard\n+ex_extra        +mouse_gpm       +statusline      -xterm_save\n+extra_search    -mouse_jsbterm   -sun_workshop    -xpm\n   system vimrc file: \"$VIM/vimrc\"\n     user vimrc file: \"$HOME/.vimrc\"\n 2nd user vimrc file: \"~/.vim/vimrc\"\n      user exrc file: \"$HOME/.exrc\"\n  fall-back for $VIM: \"/usr/share/vim\"\nCompilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H     -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1      \nLinking: gcc   -Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,--as-needed -o vim        -lm -ltinfo -lnsl  -lselinux  -lacl -lattr -lgpm -ldl    -L/usr/lib/python2.7/config-x86_64-linux-gnu -lpython2.7 -lpthread -ldl -lutil -lm -Xlinker -export-dynamic -Wl,-O1 -Wl,-Bsymbolic-functions      \n\u001b[34m\u001b[1miptables version\u001b[0m\niptables v1.4.21\n\u001b[34m\u001b[1mcurl version\u001b[0m\ncurl 7.35.0 (x86_64-pc-linux-gnu) libcurl/7.35.0 OpenSSL/1.0.1f zlib/1.2.8 libidn/1.28 librtmp/2.3\n\u001b[34m\u001b[1mwget version\u001b[0m\nGNU Wget 1.15 built on linux-gnu.\n\u001b[34m\u001b[1mrsync version\u001b[0m\nrsync  version 3.1.0  protocol version 31\n\u001b[34m\u001b[1mgimme version\u001b[0m\nv1.2.0\n\u001b[34m\u001b[1mnvm version\u001b[0m\n0.33.6\n\u001b[34m\u001b[1mperlbrew version\u001b[0m\n/home/travis/perl5/perlbrew/bin/perlbrew  - App::perlbrew/0.80\n\u001b[34m\u001b[1mphpenv version\u001b[0m\nrbenv 1.1.1-25-g6aa70b6\n\u001b[34m\u001b[1mrvm version\u001b[0m\nrvm 1.29.3 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]\n\u001b[34m\u001b[1mdefault ruby version\u001b[0m\nruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-linux]\n\u001b[34m\u001b[1mCouchDB version\u001b[0m\ncouchdb 1.6.1\n\u001b[34m\u001b[1mElasticSearch version\u001b[0m\n5.5.0\n\u001b[34m\u001b[1mInstalled Firefox version\u001b[0m\nfirefox 56.0.2\n\u001b[34m\u001b[1mMongoDB version\u001b[0m\nMongoDB 3.4.10\n\u001b[34m\u001b[1mPhantomJS version\u001b[0m\n2.1.1\n\u001b[34m\u001b[1mPre-installed PostgreSQL versions\u001b[0m\n9.2.24\n9.3.20\n9.4.15\n9.5.10\n9.6.6\n\u001b[34m\u001b[1mRabbitMQ Version\u001b[0m\n3.6.14\n\u001b[34m\u001b[1mRedis version\u001b[0m\nredis-server 4.0.6\n\u001b[34m\u001b[1mriak version\u001b[0m\n2.2.3\n\u001b[34m\u001b[1mPre-installed Go versions\u001b[0m\n1.7.4\n\u001b[34m\u001b[1mant version\u001b[0m\nApache Ant(TM) version 1.9.3 compiled on April 8 2014\n\u001b[34m\u001b[1mmvn version\u001b[0m\nApache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T07:58:13Z)\nMaven home: /usr/local/maven-3.5.2\nJava version: 1.8.0_151, vendor: Oracle Corporation\nJava home: /usr/lib/jvm/java-8-oracle/jre\nDefault locale: en_US, platform encoding: UTF-8\nOS name: \"linux\", version: \"4.4.0-98-generic\", arch: \"amd64\", family: \"unix\"\n\u001b[34m\u001b[1mgradle version\u001b[0m\n\n------------------------------------------------------------\nGradle 4.0.1\n------------------------------------------------------------\n\nBuild time:   2017-07-07 14:02:41 UTC\nRevision:     38e5dc0f772daecca1d2681885d3d85414eb6826\n\nGroovy:       2.4.11\nAnt:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015\nJVM:          1.8.0_151 (Oracle Corporation 25.151-b12)\nOS:           Linux 4.4.0-98-generic amd64\n\n\u001b[34m\u001b[1mlein version\u001b[0m\nLeiningen 2.8.1 on Java 1.8.0_151 Java HotSpot(TM) 64-Bit Server VM\n\u001b[34m\u001b[1mPre-installed Node.js versions\u001b[0m\nv4.8.6\nv6.12.0\nv6.12.1\nv8.9\nv8.9.1\n\u001b[34m\u001b[1mphpenv versions\u001b[0m\n  system\n  5.6\n* 5.6.32 (set by /home/travis/.phpenv/version)\n  7.0\n  7.0.25\n  7.1\n  7.1.11\n  hhvm\n  hhvm-stable\n\u001b[34m\u001b[1mcomposer --version\u001b[0m\nComposer version 1.5.2 2017-09-11 16:59:25\n\u001b[34m\u001b[1mPre-installed Ruby versions\u001b[0m\nruby-2.2.7\nruby-2.3.4\nruby-2.4.1\ntravis_fold:end:system_info\n\u001b[0K\ntravis_fold:start:docker_mtu\n\u001b[0Kdocker stop/waiting\ndocker start/running, process 4465\ntravis_fold:end:docker_mtu\n\u001b[0Ktravis_fold:start:resolvconf\n\u001b[0Kresolvconf stop/waiting\nresolvconf start/running\ntravis_fold:end:resolvconf\n\u001b[0K\ntravis_fold:start:git.checkout\n\u001b[0Ktravis_time:start:04ec91aa\n\u001b[0K$ git clone --depth=50 https://github.com/jwilder/nginx-proxy.git jwilder/nginx-proxy\nCloning into 'jwilder/nginx-proxy'...\nremote: Enumerating objects: 1437, done.\u001b[K\nremote: Counting objects:   0% (1/1437)   \u001b[K\nremote: Counting objects:   1% (15/1437)   \u001b[K\nremote: Counting objects:   2% (29/1437)   \u001b[K\nremote: Counting objects:   3% (44/1437)   \u001b[K\nremote: Counting objects:   4% (58/1437)   \u001b[K\nremote: Counting objects:   5% (72/1437)   \u001b[K\nremote: Counting objects:   6% (87/1437)   \u001b[K\nremote: Counting objects:   7% (101/1437)   \u001b[K\nremote: Counting objects:   8% (115/1437)   \u001b[K\nremote: Counting objects:   9% (130/1437)   \u001b[K\nremote: Counting objects:  10% (144/1437)   \u001b[K\nremote: Counting objects:  11% (159/1437)   \u001b[K\nremote: Counting objects:  12% (173/1437)   \u001b[K\nremote: Counting objects:  13% (187/1437)   \u001b[K\nremote: Counting objects:  14% (202/1437)   \u001b[K\nremote: Counting objects:  15% (216/1437)   \u001b[K\nremote: Counting objects:  16% (230/1437)   \u001b[K\nremote: Counting objects:  17% (245/1437)   \u001b[K\nremote: Counting objects:  18% (259/1437)   \u001b[K\nremote: Counting objects:  19% (274/1437)   \u001b[K\nremote: Counting objects:  20% (288/1437)   \u001b[K\nremote: Counting objects:  21% (302/1437)   \u001b[K\nremote: Counting objects:  22% (317/1437)   \u001b[K\nremote: Counting objects:  23% (331/1437)   \u001b[K\nremote: Counting objects:  24% (345/1437)   \u001b[K\nremote: Counting objects:  25% (360/1437)   \u001b[K\nremote: Counting objects:  26% (374/1437)   \u001b[K\nremote: Counting objects:  27% (388/1437)   \u001b[K\nremote: Counting objects:  28% (403/1437)   \u001b[K\nremote: Counting objects:  29% (417/1437)   \u001b[K\nremote: Counting objects:  30% (432/1437)   \u001b[K\nremote: Counting objects:  31% (446/1437)   \u001b[K\nremote: Counting objects:  32% (460/1437)   \u001b[K\nremote: Counting objects:  33% (475/1437)   \u001b[K\nremote: Counting objects:  34% (489/1437)   \u001b[K\nremote: Counting objects:  35% (503/1437)   \u001b[K\nremote: Counting objects:  36% (518/1437)   \u001b[K\nremote: Counting objects:  37% (532/1437)   \u001b[K\nremote: Counting objects:  38% (547/1437)   \u001b[K\nremote: Counting objects:  39% (561/1437)   \u001b[K\nremote: Counting objects:  40% (575/1437)   \u001b[K\nremote: Counting objects:  41% (590/1437)   \u001b[K\nremote: Counting objects:  42% (604/1437)   \u001b[K\nremote: Counting objects:  43% (618/1437)   \u001b[K\nremote: Counting objects:  44% (633/1437)   \u001b[K\nremote: Counting objects:  45% (647/1437)   \u001b[K\nremote: Counting objects:  46% (662/1437)   \u001b[K\nremote: Counting objects:  47% (676/1437)   \u001b[K\nremote: Counting objects:  48% (690/1437)   \u001b[K\nremote: Counting objects:  49% (705/1437)   \u001b[K\nremote: Counting objects:  50% (719/1437)   \u001b[K\nremote: Counting objects:  51% (733/1437)   \u001b[K\nremote: Counting objects:  52% (748/1437)   \u001b[K\nremote: Counting objects:  53% (762/1437)   \u001b[K\nremote: Counting objects:  54% (776/1437)   \u001b[K\nremote: Counting objects:  55% (791/1437)   \u001b[K\nremote: Counting objects:  56% (805/1437)   \u001b[K\nremote: Counting objects:  57% (820/1437)   \u001b[K\nremote: Counting objects:  58% (834/1437)   \u001b[K\nremote: Counting objects:  59% (848/1437)   \u001b[K\nremote: Counting objects:  60% (863/1437)   \u001b[K\nremote: Counting objects:  61% (877/1437)   \u001b[K\nremote: Counting objects:  62% (891/1437)   \u001b[K\nremote: Counting objects:  63% (906/1437)   \u001b[K\nremote: Counting objects:  64% (920/1437)   \u001b[K\nremote: Counting objects:  65% (935/1437)   \u001b[K\nremote: Counting objects:  66% (949/1437)   \u001b[K\nremote: Counting objects:  67% (963/1437)   \u001b[K\nremote: Counting objects:  68% (978/1437)   \u001b[K\nremote: Counting objects:  69% (992/1437)   \u001b[K\nremote: Counting objects:  70% (1006/1437)   \u001b[K\nremote: Counting objects:  71% (1021/1437)   \u001b[K\nremote: Counting objects:  72% (1035/1437)   \u001b[K\nremote: Counting objects:  73% (1050/1437)   \u001b[K\nremote: Counting objects:  74% (1064/1437)   \u001b[K\nremote: Counting objects:  75% (1078/1437)   \u001b[K\nremote: Counting objects:  76% (1093/1437)   \u001b[K\nremote: Counting objects:  77% (1107/1437)   \u001b[K\nremote: Counting objects:  78% (1121/1437)   \u001b[K\nremote: Counting objects:  79% (1136/1437)   \u001b[K\nremote: Counting objects:  80% (1150/1437)   \u001b[K\nremote: Counting objects:  81% (1164/1437)   \u001b[K\nremote: Counting objects:  82% (1179/1437)   \u001b[K\nremote: Counting objects:  83% (1193/1437)   \u001b[K\nremote: Counting objects:  84% (1208/1437)   \u001b[K\nremote: Counting objects:  85% (1222/1437)   \u001b[K\nremote: Counting objects:  86% (1236/1437)   \u001b[K\nremote: Counting objects:  87% (1251/1437)   \u001b[K\nremote: Counting objects:  88% (1265/1437)   \u001b[K\nremote: Counting objects:  89% (1279/1437)   \u001b[K\nremote: Counting objects:  90% (1294/1437)   \u001b[K\nremote: Counting objects:  91% (1308/1437)   \u001b[K\nremote: Counting objects:  92% (1323/1437)   \u001b[K\nremote: Counting objects:  93% (1337/1437)   \u001b[K\nremote: Counting objects:  94% (1351/1437)   \u001b[K\nremote: Counting objects:  95% (1366/1437)   \u001b[K\nremote: Counting objects:  96% (1380/1437)   \u001b[K\nremote: Counting objects:  97% (1394/1437)   \u001b[K\nremote: Counting objects:  98% (1409/1437)   \u001b[K\nremote: Counting objects:  99% (1423/1437)   \u001b[K\nremote: Counting objects: 100% (1437/1437)   \u001b[K\nremote: Counting objects: 100% (1437/1437), done.\u001b[K\nremote: Compressing objects:   0% (1/625)   \u001b[K\nremote: Compressing objects:   1% (7/625)   \u001b[K\nremote: Compressing objects:   2% (13/625)   \u001b[K\nremote: Compressing objects:   3% (19/625)   \u001b[K\nremote: Compressing objects:   4% (25/625)   \u001b[K\nremote: Compressing objects:   5% (32/625)   \u001b[K\nremote: Compressing objects:   6% (38/625)   \u001b[K\nremote: Compressing objects:   7% (44/625)   \u001b[K\nremote: Compressing objects:   8% (50/625)   \u001b[K\nremote: Compressing objects:   9% (57/625)   \u001b[K\nremote: Compressing objects:  10% (63/625)   \u001b[K\nremote: Compressing objects:  11% (69/625)   \u001b[K\nremote: Compressing objects:  12% (75/625)   \u001b[K\nremote: Compressing objects:  13% (82/625)   \u001b[K\nremote: Compressing objects:  14% (88/625)   \u001b[K\nremote: Compressing objects:  15% (94/625)   \u001b[K\nremote: Compressing objects:  16% (100/625)   \u001b[K\nremote: Compressing objects:  17% (107/625)   \u001b[K\nremote: Compressing objects:  18% (113/625)   \u001b[K\nremote: Compressing objects:  19% (119/625)   \u001b[K\nremote: Compressing objects:  20% (125/625)   \u001b[K\nremote: Compressing objects:  21% (132/625)   \u001b[K\nremote: Compressing objects:  22% (138/625)   \u001b[K\nremote: Compressing objects:  23% (144/625)   \u001b[K\nremote: Compressing objects:  24% (150/625)   \u001b[K\nremote: Compressing objects:  25% (157/625)   \u001b[K\nremote: Compressing objects:  26% (163/625)   \u001b[K\nremote: Compressing objects:  27% (169/625)   \u001b[K\nremote: Compressing objects:  28% (175/625)   \u001b[K\nremote: Compressing objects:  29% (182/625)   \u001b[K\nremote: Compressing objects:  30% (188/625)   \u001b[K\nremote: Compressing objects:  31% (194/625)   \u001b[K\nremote: Compressing objects:  32% (200/625)   \u001b[K\nremote: Compressing objects:  33% (207/625)   \u001b[K\nremote: Compressing objects:  34% (213/625)   \u001b[K\nremote: Compressing objects:  35% (219/625)   \u001b[K\nremote: Compressing objects:  36% (225/625)   \u001b[K\nremote: Compressing objects:  37% (232/625)   \u001b[K\nremote: Compressing objects:  38% (238/625)   \u001b[K\nremote: Compressing objects:  39% (244/625)   \u001b[K\nremote: Compressing objects:  40% (250/625)   \u001b[K\nremote: Compressing objects:  41% (257/625)   \u001b[K\nremote: Compressing objects:  42% (263/625)   \u001b[K\nremote: Compressing objects:  43% (269/625)   \u001b[K\nremote: Compressing objects:  44% (275/625)   \u001b[K\nremote: Compressing objects:  45% (282/625)   \u001b[K\nremote: Compressing objects:  46% (288/625)   \u001b[K\nremote: Compressing objects:  47% (294/625)   \u001b[K\nremote: Compressing objects:  48% (300/625)   \u001b[K\nremote: Compressing objects:  49% (307/625)   \u001b[K\nremote: Compressing objects:  50% (313/625)   \u001b[K\nremote: Compressing objects:  51% (319/625)   \u001b[K\nremote: Compressing objects:  52% (325/625)   \u001b[K\nremote: Compressing objects:  53% (332/625)   \u001b[K\nremote: Compressing objects:  54% (338/625)   \u001b[K\nremote: Compressing objects:  55% (344/625)   \u001b[K\nremote: Compressing objects:  56% (350/625)   \u001b[K\nremote: Compressing objects:  57% (357/625)   \u001b[K\nremote: Compressing objects:  58% (363/625)   \u001b[K\nremote: Compressing objects:  59% (369/625)   \u001b[K\nremote: Compressing objects:  60% (375/625)   \u001b[K\nremote: Compressing objects:  61% (382/625)   \u001b[K\nremote: Compressing objects:  62% (388/625)   \u001b[K\nremote: Compressing objects:  63% (394/625)   \u001b[K\nremote: Compressing objects:  64% (400/625)   \u001b[K\nremote: Compressing objects:  65% (407/625)   \u001b[K\nremote: Compressing objects:  66% (413/625)   \u001b[K\nremote: Compressing objects:  67% (419/625)   \u001b[K\nremote: Compressing objects:  68% (425/625)   \u001b[K\nremote: Compressing objects:  69% (432/625)   \u001b[K\nremote: Compressing objects:  70% (438/625)   \u001b[K\nremote: Compressing objects:  71% (444/625)   \u001b[K\nremote: Compressing objects:  72% (450/625)   \u001b[K\nremote: Compressing objects:  73% (457/625)   \u001b[K\nremote: Compressing objects:  74% (463/625)   \u001b[K\nremote: Compressing objects:  75% (469/625)   \u001b[K\nremote: Compressing objects:  76% (475/625)   \u001b[K\nremote: Compressing objects:  77% (482/625)   \u001b[K\nremote: Compressing objects:  78% (488/625)   \nremote: Compressing objects:  79% (494/625)   \u001b[K\nremote: Compressing objects:  80% (500/625)   \u001b[K\nremote: Compressing objects:  81% (507/625)   \u001b[K\nremote: Compressing objects:  82% (513/625)   \u001b[K\nremote: Compressing objects:  83% (519/625)   \u001b[K\nremote: Compressing objects:  84% (525/625)   \u001b[K\nremote: Compressing objects:  85% (532/625)   \u001b[K\nremote: Compressing objects:  86% (538/625)   \u001b[K\nremote: Compressing objects:  87% (544/625)   \u001b[K\nremote: Compressing objects:  88% (550/625)   \u001b[K\nremote: Compressing objects:  89% (557/625)   \u001b[K\nremote: Compressing objects:  90% (563/625)   \u001b[K\nremote: Compressing objects:  91% (569/625)   \u001b[K\nremote: Compressing objects:  92% (575/625)   \u001b[K\nremote: Compressing objects:  93% (582/625)   \u001b[K\nremote: Compressing objects:  94% (588/625)   \u001b[K\nremote: Compressing objects:  95% (594/625)   \u001b[K\nremote: Compressing objects:  96% (600/625)   \u001b[K\nremote: Compressing objects:  97% (607/625)   \u001b[K\nremote: Compressing objects:  98% (613/625)   \u001b[K\nremote: Compressing objects:  99% (619/625)   \u001b[K\nremote: Compressing objects: 100% (625/625)   \u001b[K\nremote: Compressing objects: 100% (625/625), done.\u001b[K\nReceiving objects:   0% (1/1437)   \nReceiving objects:   1% (15/1437)   \nReceiving objects:   2% (29/1437)   \nReceiving objects:   3% (44/1437)   \nReceiving objects:   4% (58/1437)   \nReceiving objects:   5% (72/1437)   \nReceiving objects:   6% (87/1437)   \nReceiving objects:   7% (101/1437)   \nReceiving objects:   8% (115/1437)   \nReceiving objects:   9% (130/1437)   \nReceiving objects:  10% (144/1437)   \nReceiving objects:  11% (159/1437)   \nReceiving objects:  12% (173/1437)   \nReceiving objects:  13% (187/1437)   \nReceiving objects:  14% (202/1437)   \nReceiving objects:  15% (216/1437)   \nReceiving objects:  16% (230/1437)   \nReceiving objects:  17% (245/1437)   \nReceiving objects:  18% (259/1437)   \nReceiving objects:  19% (274/1437)   \nReceiving objects:  20% (288/1437)   \nReceiving objects:  21% (302/1437)   \nReceiving objects:  22% (317/1437)   \nReceiving objects:  23% (331/1437)   \nReceiving objects:  24% (345/1437)   \nReceiving objects:  25% (360/1437)   \nReceiving objects:  26% (374/1437)   \nReceiving objects:  27% (388/1437)   \nReceiving objects:  28% (403/1437)   \nReceiving objects:  29% (417/1437)   \nReceiving objects:  30% (432/1437)   \nReceiving objects:  31% (446/1437)   \nReceiving objects:  32% (460/1437)   \nReceiving objects:  33% (475/1437)   \nReceiving objects:  34% (489/1437)   \nReceiving objects:  35% (503/1437)   \nReceiving objects:  36% (518/1437)   \nReceiving objects:  37% (532/1437)   \nReceiving objects:  38% (547/1437)   \nReceiving objects:  39% (561/1437)   \nReceiving objects:  40% (575/1437)   \nReceiving objects:  41% (590/1437)   \nReceiving objects:  42% (604/1437)   \nReceiving objects:  43% (618/1437)   \nReceiving objects:  44% (633/1437)   \nReceiving objects:  45% (647/1437)   \nReceiving objects:  46% (662/1437)   \nReceiving objects:  47% (676/1437)   \nReceiving objects:  48% (690/1437)   \nReceiving objects:  49% (705/1437)   \nReceiving objects:  50% (719/1437)   \nReceiving objects:  51% (733/1437)   \nReceiving objects:  52% (748/1437)   \nReceiving objects:  53% (762/1437)   \nReceiving objects:  54% (776/1437)   \nReceiving objects:  55% (791/1437)   \nReceiving objects:  56% (805/1437)   \nReceiving objects:  57% (820/1437)   \nReceiving objects:  58% (834/1437)   \nReceiving objects:  59% (848/1437)   \nReceiving objects:  60% (863/1437)   \nReceiving objects:  61% (877/1437)   \nReceiving objects:  62% (891/1437)   \nReceiving objects:  63% (906/1437)   \nReceiving objects:  64% (920/1437)   \nReceiving objects:  65% (935/1437)   \nReceiving objects:  66% (949/1437)   \nReceiving objects:  67% (963/1437)   \nReceiving objects:  68% (978/1437)   \nReceiving objects:  69% (992/1437)   \nReceiving objects:  70% (1006/1437)   \nReceiving objects:  71% (1021/1437)   \nReceiving objects:  72% (1035/1437)   \nReceiving objects:  73% (1050/1437)   \nremote: Total 1437 (delta 854), reused 1377 (delta 797), pack-reused 0\u001b[K\nReceiving objects:  74% (1064/1437)   \nReceiving objects:  75% (1078/1437)   \nReceiving objects:  76% (1093/1437)   \nReceiving objects:  77% (1107/1437)   \nReceiving objects:  78% (1121/1437)   \nReceiving objects:  79% (1136/1437)   \nReceiving objects:  80% (1150/1437)   \nReceiving objects:  81% (1164/1437)   \nReceiving objects:  82% (1179/1437)   \nReceiving objects:  83% (1193/1437)   \nReceiving objects:  84% (1208/1437)   \nReceiving objects:  85% (1222/1437)   \nReceiving objects:  86% (1236/1437)   \nReceiving objects:  87% (1251/1437)   \nReceiving objects:  88% (1265/1437)   \nReceiving objects:  89% (1279/1437)   \nReceiving objects:  90% (1294/1437)   \nReceiving objects:  91% (1308/1437)   \nReceiving objects:  92% (1323/1437)   \nReceiving objects:  93% (1337/1437)   \nReceiving objects:  94% (1351/1437)   \nReceiving objects:  95% (1366/1437)   \nReceiving objects:  96% (1380/1437)   \nReceiving objects:  97% (1394/1437)   \nReceiving objects:  98% (1409/1437)   \nReceiving objects:  99% (1423/1437)   \nReceiving objects: 100% (1437/1437)   \nReceiving objects: 100% (1437/1437), 351.51 KiB | 4.95 MiB/s, done.\nResolving deltas:   0% (0/854)   \nResolving deltas:   1% (13/854)   \nResolving deltas:   2% (22/854)   \nResolving deltas:   3% (26/854)   \nResolving deltas:   4% (40/854)   \nResolving deltas:   5% (46/854)   \nResolving deltas:   6% (55/854)   \nResolving deltas:   7% (64/854)   \nResolving deltas:   8% (69/854)   \nResolving deltas:   9% (81/854)   \nResolving deltas:  12% (106/854)   \nResolving deltas:  13% (118/854)   \nResolving deltas:  14% (125/854)   \nResolving deltas:  15% (132/854)   \nResolving deltas:  18% (161/854)   \nResolving deltas:  19% (163/854)   \nResolving deltas:  20% (172/854)   \nResolving deltas:  21% (185/854)   \nResolving deltas:  23% (200/854)   \nResolving deltas:  25% (214/854)   \nResolving deltas:  27% (233/854)   \nResolving deltas:  30% (258/854)   \nResolving deltas:  31% (266/854)   \nResolving deltas:  33% (285/854)   \nResolving deltas:  34% (295/854)   \nResolving deltas:  35% (302/854)   \nResolving deltas:  36% (308/854)   \nResolving deltas:  37% (317/854)   \nResolving deltas:  39% (337/854)   \nResolving deltas:  41% (352/854)   \nResolving deltas:  42% (363/854)   \nResolving deltas:  43% (368/854)   \nResolving deltas:  44% (380/854)   \nResolving deltas:  46% (401/854)   \nResolving deltas:  48% (411/854)   \nResolving deltas:  49% (421/854)   \nResolving deltas:  50% (429/854)   \nResolving deltas:  64% (547/854)   \nResolving deltas:  65% (561/854)   \nResolving deltas:  66% (566/854)   \nResolving deltas:  67% (574/854)   \nResolving deltas:  68% (588/854)   \nResolving deltas:  70% (599/854)   \nResolving deltas:  71% (610/854)   \nResolving deltas:  72% (615/854)   \nResolving deltas:  75% (645/854)   \nResolving deltas:  76% (652/854)   \nResolving deltas:  77% (659/854)   \nResolving deltas:  81% (699/854)   \nResolving deltas:  83% (711/854)   \nResolving deltas:  84% (720/854)   \nResolving deltas:  85% (728/854)   \nResolving deltas:  89% (765/854)   \nResolving deltas:  90% (769/854)   \nResolving deltas:  92% (788/854)   \nResolving deltas:  93% (795/854)   \nResolving deltas:  94% (803/854)   \nResolving deltas:  95% (813/854)   \nResolving deltas:  96% (820/854)   \nResolving deltas:  97% (830/854)   \nResolving deltas:  98% (840/854)   \nResolving deltas:  99% (848/854)   \nResolving deltas: 100% (854/854)   \nResolving deltas: 100% (854/854), done.\ntravis_time:end:04ec91aa:start=1564473782345108324,finish=1564473784926104246,duration=2580995922\n\u001b[0K$ cd jwilder/nginx-proxy\ntravis_time:start:00d84b60\n\u001b[0K$ git fetch origin +refs/pull/1308/merge:\nremote: Enumerating objects: 67, done.\u001b[K\nremote: Counting objects:   1% (1/63)   \u001b[K\nremote: Counting objects:   3% (2/63)   \u001b[K\nremote: Counting objects:   4% (3/63)   \u001b[K\nremote: Counting objects:   6% (4/63)   \u001b[K\nremote: Counting objects:   7% (5/63)   \u001b[K\nremote: Counting objects:   9% (6/63)   \u001b[K\nremote: Counting objects:  11% (7/63)   \u001b[K\nremote: Counting objects:  12% (8/63)   \u001b[K\nremote: Counting objects:  14% (9/63)   \u001b[K\nremote: Counting objects:  15% (10/63)   \u001b[K\nremote: Counting objects:  17% (11/63)   \u001b[K\nremote: Counting objects:  19% (12/63)   \u001b[K\nremote: Counting objects:  20% (13/63)   \u001b[K\nremote: Counting objects:  22% (14/63)   \u001b[K\nremote: Counting objects:  23% (15/63)   \u001b[K\nremote: Counting objects:  25% (16/63)   \u001b[K\nremote: Counting objects:  26% (17/63)   \u001b[K\nremote: Counting objects:  28% (18/63)   \u001b[K\nremote: Counting objects:  30% (19/63)   \u001b[K\nremote: Counting objects:  31% (20/63)   \u001b[K\nremote: Counting objects:  33% (21/63)   \u001b[K\nremote: Counting objects:  34% (22/63)   \u001b[K\nremote: Counting objects:  36% (23/63)   \u001b[K\nremote: Counting objects:  38% (24/63)   \u001b[K\nremote: Counting objects:  39% (25/63)   \u001b[K\nremote: Counting objects:  41% (26/63)   \u001b[K\nremote: Counting objects:  42% (27/63)   \u001b[K\nremote: Counting objects:  44% (28/63)   \u001b[K\nremote: Counting objects:  46% (29/63)   \u001b[K\nremote: Counting objects:  47% (30/63)   \u001b[K\nremote: Counting objects:  49% (31/63)   \u001b[K\nremote: Counting objects:  50% (32/63)   \u001b[K\nremote: Counting objects:  52% (33/63)   \u001b[K\nremote: Counting objects:  53% (34/63)   \u001b[K\nremote: Counting objects:  55% (35/63)   \u001b[K\nremote: Counting objects:  57% (36/63)   \u001b[K\nremote: Counting objects:  58% (37/63)   \u001b[K\nremote: Counting objects:  60% (38/63)   \u001b[K\nremote: Counting objects:  61% (39/63)   \u001b[K\nremote: Counting objects:  63% (40/63)   \u001b[K\nremote: Counting objects:  65% (41/63)   \u001b[K\nremote: Counting objects:  66% (42/63)   \u001b[K\nremote: Counting objects:  68% (43/63)   \u001b[K\nremote: Counting objects:  69% (44/63)   \u001b[K\nremote: Counting objects:  71% (45/63)   \u001b[K\nremote: Counting objects:  73% (46/63)   \u001b[K\nremote: Counting objects:  74% (47/63)   \u001b[K\nremote: Counting objects:  76% (48/63)   \u001b[K\nremote: Counting objects:  77% (49/63)   \u001b[K\nremote: Counting objects:  79% (50/63)   \u001b[K\nremote: Counting objects:  80% (51/63)   \u001b[K\nremote: Counting objects:  82% (52/63)   \u001b[K\nremote: Counting objects:  84% (53/63)   \u001b[K\nremote: Counting objects:  85% (54/63)   \u001b[K\nremote: Counting objects:  87% (55/63)   \u001b[K\nremote: Counting objects:  88% (56/63)   \u001b[K\nremote: Counting objects:  90% (57/63)   \u001b[K\nremote: Counting objects:  92% (58/63)   \u001b[K\nremote: Counting objects:  93% (59/63)   \u001b[K\nremote: Counting objects:  95% (60/63)   \u001b[K\nremote: Counting objects:  96% (61/63)   \u001b[K\nremote: Counting objects:  98% (62/63)   \u001b[K\nremote: Counting objects: 100% (63/63)   \u001b[K\nremote: Counting objects: 100% (63/63), done.\u001b[K\nremote: Compressing objects:   5% (1/18)   \u001b[K\nremote: Compressing objects:  11% (2/18)   \u001b[K\nremote: Compressing objects:  16% (3/18)   \u001b[K\nremote: Compressing objects:  22% (4/18)   \u001b[K\nremote: Compressing objects:  27% (5/18)   \u001b[K\nremote: Compressing objects:  33% (6/18)   \u001b[K\nremote: Compressing objects:  38% (7/18)   \u001b[K\nremote: Compressing objects:  44% (8/18)   \u001b[K\nremote: Compressing objects:  50% (9/18)   \u001b[K\nremote: Compressing objects:  55% (10/18)   \u001b[K\nremote: Compressing objects:  61% (11/18)   \u001b[K\nremote: Compressing objects:  66% (12/18)   \u001b[K\nremote: Compressing objects:  72% (13/18)   \u001b[K\nremote: Compressing objects:  77% (14/18)   \u001b[K\nremote: Compressing objects:  83% (15/18)   \u001b[K\nremote: Compressing objects:  88% (16/18)   \u001b[K\nremote: Compressing objects:  94% (17/18)   \u001b[K\nremote: Compressing objects: 100% (18/18)   \u001b[K\nremote: Compressing objects: 100% (18/18), done.\u001b[K\nremote: Total 30 (delta 17), reused 21 (delta 11), pack-reused 0\u001b[K\nUnpacking objects:   3% (1/30)   \nUnpacking objects:   6% (2/30)   \nUnpacking objects:  10% (3/30)   \nUnpacking objects:  13% (4/30)   \nUnpacking objects:  16% (5/30)   \nUnpacking objects:  20% (6/30)   \nUnpacking objects:  23% (7/30)   \nUnpacking objects:  26% (8/30)   \nUnpacking objects:  30% (9/30)   \nUnpacking objects:  33% (10/30)   \nUnpacking objects:  36% (11/30)   \nUnpacking objects:  40% (12/30)   \nUnpacking objects:  43% (13/30)   \nUnpacking objects:  46% (14/30)   \nUnpacking objects:  50% (15/30)   \nUnpacking objects:  53% (16/30)   \nUnpacking objects:  56% (17/30)   \nUnpacking objects:  60% (18/30)   \nUnpacking objects:  63% (19/30)   \nUnpacking objects:  66% (20/30)   \nUnpacking objects:  70% (21/30)   \nUnpacking objects:  73% (22/30)   \nUnpacking objects:  76% (23/30)   \nUnpacking objects:  80% (24/30)   \nUnpacking objects:  83% (25/30)   \nUnpacking objects:  86% (26/30)   \nUnpacking objects:  90% (27/30)   \nUnpacking objects:  93% (28/30)   \nUnpacking objects:  96% (29/30)   \nUnpacking objects: 100% (30/30)   \nUnpacking objects: 100% (30/30), done.\nFrom https://github.com/jwilder/nginx-proxy\n * branch            refs/pull/1308/merge -> FETCH_HEAD\ntravis_time:end:00d84b60:start=1564473784930691823,finish=1564473786455637964,duration=1524946141\n\u001b[0K$ git checkout -qf FETCH_HEAD\ntravis_fold:end:git.checkout\n\u001b[0K\n\n\u001b[33;1mSetting environment variables from .travis.yml\u001b[0m\n$ export TEST_TARGET=test-debian\n\ntravis_fold:start:rvm\n\u001b[0Ktravis_time:start:2818f3e5\n\u001b[0K$ rvm use default\n\u001b[32mUsing /home/travis/.rvm/gems/ruby-2.4.1\u001b[0m\n\n\u001b[32;1m** Updating RubyGems to the latest compatible version for security reasons. **\u001b[0m\n\u001b[32;1m** If you need an older version, you can downgrade with 'gem update --system OLD_VERSION'. **\u001b[0m\n\ntravis_time:end:2818f3e5:start=1564473786476422383,finish=1564473790779622174,duration=4303199791\n\u001b[0Ktravis_fold:end:rvm\n\u001b[0K\ntravis_fold:start:ruby.versions\n\u001b[0K$ ruby --version\nruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-linux]\n$ rvm --version\nrvm 1.29.3 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]\n$ bundle --version\nBundler version 1.17.3\n$ gem --version\n3.0.4\ntravis_fold:end:ruby.versions\n\u001b[0K\ntravis_fold:start:before_install.1\n\u001b[0Ktravis_time:start:108fb4ec\n\u001b[0K$ sudo apt-get -y remove docker docker-engine docker-ce\n\nReading package lists... 0%\n\nReading package lists... 100%\n\nReading package lists... Done\n\n\nBuilding dependency tree... 0%\n\nBuilding dependency tree... 0%\n\nBuilding dependency tree... 50%\n\nBuilding dependency tree... 50%\n\nBuilding dependency tree       \n\n\nReading state information... 0%\n\nReading state information... 0%\n\nReading state information... Done\n\nPackage 'docker-engine' is not installed, so not removed\nPackage 'docker' is not installed, so not removed\nThe following packages were automatically installed and are no longer required:\n  aufs-tools cgroup-lite libsystemd-journal0\nUse 'sudo apt autoremove' to remove them.\nThe following packages will be REMOVED:\n  docker-ce\n0 upgraded, 0 newly installed, 1 to remove and 303 not upgraded.\nAfter this operation, 99.3 MB disk space will be freed.\n(Reading database ... \n(Reading database ... 5%\n(Reading database ... 10%\n(Reading database ... 15%\n(Reading database ... 20%\n(Reading database ... 25%\n(Reading database ... 30%\n(Reading database ... 35%\n(Reading database ... 40%\n(Reading database ... 45%\n(Reading database ... 50%\n(Reading database ... 55%\n(Reading database ... 60%\n(Reading database ... 65%\n(Reading database ... 70%\n(Reading database ... 75%\n(Reading database ... 80%\n(Reading database ... 85%\n(Reading database ... 90%\n(Reading database ... 95%\n(Reading database ... 100%\n(Reading database ... 93695 files and directories currently installed.)\nRemoving docker-ce (17.09.0~ce-0~ubuntu) ...\ndocker stop/waiting\nProcessing triggers for man-db (2.6.7.1-1ubuntu1) ...\ntravis_time:end:108fb4ec:start=1564473791245100699,finish=1564473794041401926,duration=2796301227\n\u001b[0Ktravis_fold:end:before_install.1\n\u001b[0Ktravis_fold:start:before_install.2\n\u001b[0Ktravis_time:start:1072f8c0\n\u001b[0K$ sudo rm /etc/apt/sources.list.d/docker.list\ntravis_time:end:1072f8c0:start=1564473794045447963,finish=1564473794053478684,duration=8030721\n\u001b[0Ktravis_fold:end:before_install.2\n\u001b[0Ktravis_fold:start:before_install.3\n\u001b[0Ktravis_time:start:0b1e331c\n\u001b[0K$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\nOK\ntravis_time:end:0b1e331c:start=1564473794057576591,finish=1564473794255297799,duration=197721208\n\u001b[0Ktravis_fold:end:before_install.3\n\u001b[0Ktravis_fold:start:before_install.4\n\u001b[0Ktravis_time:start:0b498e8a\n\u001b[0K$ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\ntravis_time:end:0b498e8a:start=1564473794259496523,finish=1564473794663517152,duration=404020629\n\u001b[0Ktravis_fold:end:before_install.4\n\u001b[0Ktravis_fold:start:before_install.5\n\u001b[0Ktravis_time:start:287907de\n\u001b[0K$ sudo apt-get update\n\n0% [Working]\n            \nHit:1 http://security.ubuntu.com/ubuntu trusty-security InRelease\n\n0% [Connecting to apt.cache.travis-ci.com (34.96.81.152)] [Waiting for headers]\n                                                                               \nHit:2 http://dl.hhvm.com/ubuntu trusty InRelease\n\n                                                                               \nHit:4 http://ppa.launchpad.net/chris-lea/redis-server/ubuntu trusty InRelease\n\n                                                                               \nHit:6 http://apt.postgresql.org/pub/repos/apt trusty-pgdg InRelease\n\n0% [Waiting for headers] [Waiting for headers] [Connecting to apt.cache.travis-\n0% [1 InRelease gpgv 65.9 kB] [Waiting for headers] [Waiting for headers] [Conn\n0% [Connecting to apt.cache.travis-ci.com] [1 InRelease gpgv 65.9 kB] [Waiting \n                                                                               \nHit:3 http://dl.bintray.com/apache/cassandra 39x InRelease\n\n0% [1 InRelease gpgv 65.9 kB] [Waiting for headers] [Waiting for headers] [Wait\n                                                                               \nIgn:7 http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.4 InRelease\n\n0% [Waiting for headers] [1 InRelease gpgv 65.9 kB] [Waiting for headers] [Wait\n                                                                               \nHit:8 http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.4 Release\n\n0% [Waiting for headers] [1 InRelease gpgv 65.9 kB] [Waiting for headers] [Wait\n                                                                               \nIgn:9 http://us-east-1.ec2.archive.ubuntu.com/ubuntu trusty InRelease\n\n0% [Waiting for headers] [1 InRelease gpgv 65.9 kB] [Waiting for headers] [Wait\n                                                                               \nHit:10 http://us-east-1.ec2.archive.ubuntu.com/ubuntu trusty-updates InRelease\n\n0% [Waiting for headers] [1 InRelease gpgv 65.9 kB] [Waiting for headers] [Wait\n                                                                               \nHit:11 http://us-east-1.ec2.archive.ubuntu.com/ubuntu trusty-backports InRelease\n\n0% [Waiting for headers] [1 InRelease gpgv 65.9 kB] [Waiting for headers] [Wait\n                                                                               \nHit:12 http://us-east-1.ec2.archive.ubuntu.com/ubuntu trusty Release\n\n0% [Waiting for headers] [1 InRelease gpgv 65.9 kB] [Waiting for headers] [Wait\n                                                                               \nIgn:5 http://heroku-toolbelt.s3.amazonaws.com/apt ./ InRelease\n\n                                                                               \n0% [Waiting for headers] [Waiting for headers]\n0% [2 InRelease gpgv 3,106 B] [Waiting for headers] [Waiting for headers]\n0% [2 InRelease gpgv 3,106 B] [Waiting for headers] [Waiting for headers]\n0% [2 InRelease gpgv 3,106 B] [Waiting for headers] [Waiting for headers]\n                                                                         \nHit:13 http://heroku-toolbelt.s3.amazonaws.com/apt ./ Release\n\n0% [2 InRelease gpgv 3,106 B] [Waiting for headers] [Waiting for headers]\n                                                                         \n0% [Waiting for headers] [Waiting for headers]\n0% [4 InRelease gpgv 15.4 kB] [Waiting for headers] [Waiting for headers]\n                                                                         \nHit:14 https://download.docker.com/linux/ubuntu trusty InRelease\n\n0% [4 InRelease gpgv 15.4 kB] [Waiting for headers] [Waiting for headers]\n                                                                         \nIgn:15 http://ppa.launchpad.net/couchdb/stable/ubuntu trusty InRelease\n\n0% [4 InRelease gpgv 15.4 kB] [Waiting for headers] [Waiting for headers]\n                                                                         \nHit:16 http://ppa.launchpad.net/git-core/ppa/ubuntu trusty InRelease\n\n0% [4 InRelease gpgv 15.4 kB] [Waiting for headers] [Waiting for headers]\n                                                                         \nHit:17 http://ppa.launchpad.net/openjdk-r/ppa/ubuntu trusty InRelease\n\n0% [4 InRelease gpgv 15.4 kB] [Waiting for headers] [Waiting for headers]\n                                                                         \nHit:18 http://ppa.launchpad.net/pollinate/ppa/ubuntu trusty InRelease\n\n                                                                         \n0% [4 InRelease gpgv 15.4 kB] [Waiting for headers]\n                                                   \nHit:19 http://ppa.launchpad.net/webupd8team/java/ubuntu trusty InRelease\n\n0% [4 InRelease gpgv 15.4 kB] [Waiting for headers]\n                                                   \nHit:20 http://ppa.launchpad.net/couchdb/stable/ubuntu trusty Release\n\n0% [4 InRelease gpgv 15.4 kB] [Waiting for headers]\n                                                   \n0% [Waiting for headers]\n0% [6 InRelease gpgv 56.5 kB] [Waiting for headers]\n                                                   \nIgn:21 http://dl.google.com/linux/chrome/deb stable InRelease\n\n                                                   \n0% [6 InRelease gpgv 56.5 kB]\n                             \n0% [Waiting for headers]\n0% [3 InRelease gpgv 3,168 B] [Waiting for headers]\n                                                   \nHit:22 http://dl.google.com/linux/chrome/deb stable Release\n\n                                                   \n0% [3 InRelease gpgv 3,168 B]\n                             \n0% [Working]\n0% [Release.gpg gpgv 2,495 B]\n                             \n0% [Working]\n0% [10 InRelease gpgv 65.9 kB]\n                              \n0% [Working]\n0% [11 InRelease gpgv 65.9 kB]\n                              \n0% [Working]\n0% [Release.gpg gpgv 58.5 kB]\n                             \n0% [Working]\n0% [Release.gpg gpgv 1,609 B]\n                             \n0% [Working]\n0% [14 InRelease gpgv 37.1 kB]\n                              \n0% [Working]\n0% [16 InRelease gpgv 20.8 kB]\n                              \n0% [Working]\n0% [17 InRelease gpgv 15.4 kB]\n                              \n0% [Working]\n0% [18 InRelease gpgv 15.4 kB]\n                              \n0% [Working]\n0% [19 InRelease gpgv 15.5 kB]\n                              \n0% [Working]\n0% [Release.gpg gpgv 15.1 kB]\n                             \nHit:26 https://packagecloud.io/computology/apt-backport/ubuntu trusty InRelease\n\n0% [Release.gpg gpgv 15.1 kB]\n                             \n0% [Working]\n0% [Release.gpg gpgv 943 B]\n                           \n0% [Working]\n0% [26 InRelease gpgv 23.5 kB]\n                              \n0% [Working]\n            \nGet:29 https://packagecloud.io/github/git-lfs/ubuntu trusty InRelease [23.2 kB]\n\n0% [29 InRelease 15.8 kB/23.2 kB 68%]\n                                     \n0% [Working]\n0% [29 InRelease gpgv 23.2 kB]\n                              \nIgn:29 https://packagecloud.io/github/git-lfs/ubuntu trusty InRelease\n\n                              \n0% [Working]\n            \nHit:30 https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu trusty InRelease\n\n0% [Working]\n0% [30 InRelease gpgv 23.7 kB]\n                              \n20% [Working]\n             \nFetched 23.2 kB in 1s (16.3 kB/s)\n\nReading package lists... 0%\n\nReading package lists... 0%\n\nReading package lists... 1%\n\nReading package lists... 5%\n\nReading package lists... 5%\n\nReading package lists... 11%\n\nReading package lists... 11%\n\nReading package lists... 11%\n\nReading package lists... 11%\n\nReading package lists... 11%\n\nReading package lists... 11%\n\nReading package lists... 34%\n\nReading package lists... 34%\n\nReading package lists... 42%\n\nReading package lists... 56%\n\nReading package lists... 56%\n\nReading package lists... 56%\n\nReading package lists... 56%\n\nReading package lists... 57%\n\nReading package lists... 57%\n\nReading package lists... 63%\n\nReading package lists... 63%\n\nReading package lists... 68%\n\nReading package lists... 68%\n\nReading package lists... 74%\n\nReading package lists... 74%\n\nReading package lists... 74%\n\nReading package lists... 74%\n\nReading package lists... 75%\n\nReading package lists... 75%\n\nReading package lists... 75%\n\nReading package lists... 75%\n\nReading package lists... 77%\n\nReading package lists... 77%\n\nReading package lists... 79%\n\nReading package lists... 79%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 80%\n\nReading package lists... 81%\n\nReading package lists... 81%\n\nReading package lists... 81%\n\nReading package lists... 81%\n\nReading package lists... 81%\n\nReading package lists... 81%\n\nReading package lists... 81%\n\nReading package lists... 81%\n\nReading package lists... 85%\n\nReading package lists... 85%\n\nReading package lists... 88%\n\nReading package lists... 88%\n\nReading package lists... 94%\n\nReading package lists... 94%\n\nReading package lists... 94%\n\nReading package lists... 94%\n\nReading package lists... 94%\n\nReading package lists... 94%\n\nReading package lists... 94%\n\nReading package lists... 94%\n\nReading package lists... 95%\n\nReading package lists... 95%\n\nReading package lists... 96%\n\nReading package lists... 96%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 97%\n\nReading package lists... 98%\n\nReading package lists... 98%\n\nReading package lists... 98%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... 99%\n\nReading package lists... Done\n\nW: http://ppa.launchpad.net/couchdb/stable/ubuntu/dists/trusty/Release.gpg: Signature by key 15866BAFD9BCC4F3C1E0DFC7D69548E1C17EAB57 uses weak digest algorithm (SHA1)\nW: GPG error: https://packagecloud.io/github/git-lfs/ubuntu trusty InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 6B05F25D762E3157\nW: The repository 'https://packagecloud.io/github/git-lfs/ubuntu trusty InRelease' is not signed.\nN: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.\nN: See apt-secure(8) manpage for repository creation and user configuration details.\nW: There is no public key available for the following key IDs:\n6B05F25D762E3157  \ntravis_time:end:287907de:start=1564473794667787294,finish=1564473797808435251,duration=3140647957\n\u001b[0Ktravis_fold:end:before_install.5\n\u001b[0Ktravis_fold:start:before_install.6\n\u001b[0Ktravis_time:start:0f229710\n\u001b[0K$ sudo apt-get -y install docker-ce\n\nReading package lists... 0%\n\nReading package lists... 100%\n\nReading package lists... Done\n\n\nBuilding dependency tree... 0%\n\nBuilding dependency tree... 0%\n\nBuilding dependency tree... 50%\n\nBuilding dependency tree... 50%\n\nBuilding dependency tree       \n\n\nReading state information... 0%\n\nReading state information... 0%\n\nReading state information... Done\n\nThe following additional packages will be installed:\n  pigz\nThe following NEW packages will be installed:\n  docker-ce pigz\n0 upgraded, 2 newly installed, 0 to remove and 303 not upgraded.\nNeed to get 39.8 MB of archives.\nAfter this operation, 201 MB of additional disk space will be used.\n\n0% [Working]\n            \nGet:1 http://us-east-1.ec2.archive.ubuntu.com/ubuntu trusty/universe amd64 pigz amd64 2.3-2 [59.4 kB]\n\n0% [1 pigz 13.4 kB/59.4 kB 23%]\n                               \n10% [Working]\n             \nGet:2 https://download.docker.com/linux/ubuntu trusty/stable amd64 docker-ce amd64 18.06.3~ce~3-0~ubuntu [39.7 MB]\n\n10% [2 docker-ce 0 B/39.7 MB 0%]\n41% [2 docker-ce 15.2 MB/39.7 MB 38%]\n73% [2 docker-ce 31.2 MB/39.7 MB 79%]\n                                     \n100% [Working]\n              \nFetched 39.8 MB in 1s (28.4 MB/s)\nSelecting previously unselected package pigz.\n(Reading database ... \n(Reading database ... 5%\n(Reading database ... 10%\n(Reading database ... 15%\n(Reading database ... 20%\n(Reading database ... 25%\n(Reading database ... 30%\n(Reading database ... 35%\n(Reading database ... 40%\n(Reading database ... 45%\n(Reading database ... 50%\n(Reading database ... 55%\n(Reading database ... 60%\n(Reading database ... 65%\n(Reading database ... 70%\n(Reading database ... 75%\n(Reading database ... 80%\n(Reading database ... 85%\n(Reading database ... 90%\n(Reading database ... 95%\n(Reading database ... 100%\n(Reading database ... 93493 files and directories currently installed.)\nPreparing to unpack .../archives/pigz_2.3-2_amd64.deb ...\nUnpacking pigz (2.3-2) ...\nSelecting previously unselected package docker-ce.\nPreparing to unpack .../docker-ce_18.06.3~ce~3-0~ubuntu_amd64.deb ...\nUnpacking docker-ce (18.06.3~ce~3-0~ubuntu) ...\nProcessing triggers for man-db (2.6.7.1-1ubuntu1) ...\nProcessing triggers for ureadahead (0.100.0-16) ...\nSetting up pigz (2.3-2) ...\nSetting up docker-ce (18.06.3~ce~3-0~ubuntu) ...\nInstalling new version of config file /etc/bash_completion.d/docker ...\ndocker start/running, process 7670\ntravis_time:end:0f229710:start=1564473797812955213,finish=1564473806767151793,duration=8954196580\n\u001b[0Ktravis_fold:end:before_install.6\n\u001b[0Ktravis_fold:start:before_install.7\n\u001b[0Ktravis_time:start:0069c83d\n\u001b[0K$ docker version\nClient:\n Version:           18.06.3-ce\n API version:       1.38\n Go version:        go1.10.3\n Git commit:        d7080c1\n Built:             Wed Feb 20 02:27:13 2019\n OS/Arch:           linux/amd64\n Experimental:      false\n\nServer:\n Engine:\n  Version:          18.06.3-ce\n  API version:      1.38 (minimum version 1.12)\n  Go version:       go1.10.3\n  Git commit:       d7080c1\n  Built:            Wed Feb 20 02:25:38 2019\n  OS/Arch:          linux/amd64\n  Experimental:     false\ntravis_time:end:0069c83d:start=1564473806771884554,finish=1564473806846351492,duration=74466938\n\u001b[0Ktravis_fold:end:before_install.7\n\u001b[0Ktravis_fold:start:before_install.8\n\u001b[0Ktravis_time:start:16403597\n\u001b[0K$ docker info\nContainers: 0\n Running: 0\n Paused: 0\n Stopped: 0\nImages: 0\nServer Version: 18.06.3-ce\nStorage Driver: overlay2\n Backing Filesystem: extfs\n Supports d_type: true\n Native Overlay Diff: true\nLogging Driver: json-file\nCgroup Driver: cgroupfs\nPlugins:\n Volume: local\n Network: bridge host macvlan null overlay\n Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog\nSwarm: inactive\nRuntimes: runc\nDefault Runtime: runc\nInit Binary: docker-init\ncontainerd version: 468a545b9edcd5932818eb9de8e72413e616e86e\nrunc version: a592beb5bc4c4092b1b1bac971afed27687340c5\ninit version: fec3683\nKernel Version: 4.4.0-101-generic\nOperating System: Ubuntu 14.04.5 LTS\nOSType: linux\nArchitecture: x86_64\nCPUs: 2\nTotal Memory: 7.305GiB\nName: travis-job-f6734fb8-99bc-4819-8822-be8aa6f6f806\nID: DH3M:23FP:35CF:LCVT:ROBH:CV5W:C5W2:JSP4:7G7W:NH4L:6FOS:WJOW\nDocker Root Dir: /var/lib/docker\nDebug Mode (client): false\nDebug Mode (server): false\nRegistry: https://index.docker.io/v1/\nLabels:\nExperimental: false\nInsecure Registries:\n 127.0.0.0/8\nLive Restore Enabled: false\n\ntravis_time:end:16403597:start=1564473806850976837,finish=1564473806929025794,duration=78048957\n\u001b[0Ktravis_fold:end:before_install.8\n\u001b[0Ktravis_fold:start:before_install.9\n\u001b[0Ktravis_time:start:027a39d4\n\u001b[0K$ make update-dependencies\nSending build context to Docker daemon   5.12kB\n\n\nStep 1/5 : FROM python:3\n3: Pulling from library/python\n\n\u001b[1A\u001b[1K\u001b[K\n5ae19949497e: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\ned3d96a2798e: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\nf12136850781: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\n1a9ad5d5550b: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\n6f18049a0455: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\nce39fa9d79d1: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\n3a91ffcf88ea: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\nee82cc8e1506: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\nf0fe55e0f617: Pulling fs layer \n\u001b[1B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Waiting \n\u001b[6B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Waiting \n\u001b[5B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Waiting \n\u001b[4B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Waiting \n\u001b[3B\u001b[2A\u001b[1K\u001b[K\nee82cc8e1506: Waiting \n\u001b[2B\u001b[1A\u001b[1K\u001b[K\nf0fe55e0f617: Waiting \n\u001b[1B\u001b[7A\u001b[1K\u001b[K\nf12136850781: Downloading  101.7kB/9.978MB\n\u001b[7B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Downloading  514.7kB/50.38MB\n\u001b[9B\u001b[8A\u001b[1K\u001b[K\ned3d96a2798e: Downloading  81.57kB/7.804MB\n\u001b[8B\u001b[7A\u001b[1K\u001b[K\nf12136850781: Downloading  5.364MB/9.978MB\n\u001b[7B\u001b[8A\u001b[1K\u001b[K\ned3d96a2798e: Downloading    6.2MB/7.804MB\n\u001b[8B\u001b[8A\u001b[1K\u001b[K\ned3d96a2798e: Verifying Checksum \n\u001b[8B\u001b[8A\u001b[1K\u001b[K\ned3d96a2798e: Download complete \n\u001b[8B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Downloading  10.17MB/50.38MB\n\u001b[9B\u001b[7A\u001b[1K\u001b[K\nf12136850781: Verifying Checksum \n\u001b[7B\u001b[7A\u001b[1K\u001b[K\nf12136850781: Download complete \n\u001b[7B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Downloading  21.33MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Downloading  35.06MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Downloading  47.27MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Verifying Checksum \n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Download complete \n\u001b[9B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Downloading  523.4kB/51.77MB\n\u001b[6B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  535.2kB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  524.3kB/50.38MB\n\u001b[9B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Downloading  7.335MB/51.77MB\n\u001b[6B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  9.116MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  1.573MB/50.38MB\n\u001b[9B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Downloading  16.26MB/51.77MB\n\u001b[6B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading   16.6MB/192.3MB\n\u001b[5B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Downloading  59.38kB/5.792MB\n\u001b[4B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  2.097MB/50.38MB\n\u001b[9B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Downloading  26.76MB/51.77MB\n\u001b[6B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading   24.1MB/192.3MB\n\u001b[5B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Downloading  2.063MB/5.792MB\n\u001b[4B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  2.621MB/50.38MB\n\u001b[9B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Downloading   34.1MB/51.77MB\n\u001b[6B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  30.49MB/192.3MB\n\u001b[5B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Downloading   4.91MB/5.792MB\n\u001b[4B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Verifying Checksum \n\u001b[4B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Download complete \n\u001b[4B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Downloading  40.93MB/51.77MB\n\u001b[6B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  35.84MB/192.3MB\n\u001b[5B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Downloading  48.81MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Verifying Checksum \n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Download complete \n\u001b[6B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  3.146MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading   44.4MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  54.02MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  5.243MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  60.46MB/192.3MB\n\u001b[5B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Downloading    269kB/26.57MB\n\u001b[3B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  67.39MB/192.3MB\n\u001b[5B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Downloading   5.68MB/26.57MB\n\u001b[3B\u001b[2A\u001b[1K\u001b[K\nee82cc8e1506: Downloading     235B/235B\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\nee82cc8e1506: Verifying Checksum \n\u001b[2B\u001b[2A\u001b[1K\u001b[K\nee82cc8e1506: Download complete \n\u001b[2B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading   76.5MB/192.3MB\n\u001b[5B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Downloading  14.81MB/26.57MB\n\u001b[3B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting   7.34MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  85.09MB/192.3MB\n\u001b[5B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Downloading  24.89MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Verifying Checksum \n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Download complete \n\u001b[3B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  7.864MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  93.13MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  9.961MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  103.3MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  11.01MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  112.9MB/192.3MB\n\u001b[5B\u001b[1A\u001b[1K\u001b[K\nf0fe55e0f617: Downloading  19.65kB/1.863MB\n\u001b[1B\u001b[1A\u001b[1K\u001b[K\nf0fe55e0f617: Verifying Checksum \n\u001b[1B\u001b[1A\u001b[1K\u001b[K\nf0fe55e0f617: Download complete \n\u001b[1B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  13.63MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  120.4MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  129.5MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  16.25MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  134.9MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  18.35MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  142.4MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting   21.5MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  150.9MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  24.12MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  161.1MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  171.3MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  26.21MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  178.8MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  29.88MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Downloading  185.8MB/192.3MB\n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  35.65MB/50.38MB\n\u001b[9B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Verifying Checksum \n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Download complete \n\u001b[5B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  38.27MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  39.85MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  42.47MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  45.09MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  47.71MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  49.28MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  49.81MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Extracting  50.38MB/50.38MB\n\u001b[9B\u001b[9A\u001b[1K\u001b[K\n5ae19949497e: Pull complete \n\u001b[9B\u001b[8A\u001b[1K\u001b[K\ned3d96a2798e: Extracting   98.3kB/7.804MB\n\u001b[8B\u001b[8A\u001b[1K\u001b[K\ned3d96a2798e: Extracting  1.376MB/7.804MB\n\u001b[8B\u001b[8A\u001b[1K\u001b[K\ned3d96a2798e: Extracting  5.112MB/7.804MB\n\u001b[8B\u001b[8A\u001b[1K\u001b[K\ned3d96a2798e: Extracting  7.804MB/7.804MB\n\u001b[8B\u001b[8A\u001b[1K\u001b[K\ned3d96a2798e: Pull complete \n\u001b[8B\u001b[7A\u001b[1K\u001b[K\nf12136850781: Extracting  131.1kB/9.978MB\n\u001b[7B\u001b[7A\u001b[1K\u001b[K\nf12136850781: Extracting  2.097MB/9.978MB\n\u001b[7B\u001b[7A\u001b[1K\u001b[K\nf12136850781: Extracting  8.258MB/9.978MB\n\u001b[7B\u001b[7A\u001b[1K\u001b[K\nf12136850781: Extracting  9.978MB/9.978MB\n\u001b[7B\u001b[7A\u001b[1K\u001b[K\nf12136850781: Pull complete \n\u001b[7B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  524.3kB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  4.719MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  8.913MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  13.63MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  18.35MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  19.92MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  22.02MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  23.59MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  25.17MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  26.74MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  29.36MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  31.98MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  34.08MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  36.18MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  37.22MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  40.89MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  42.99MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  45.09MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  47.19MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  48.23MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  49.28MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  50.86MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  51.38MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Extracting  51.77MB/51.77MB\n\u001b[6B\u001b[6A\u001b[1K\u001b[K\n1a9ad5d5550b: Pull complete \n\u001b[6B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  557.1kB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  4.456MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  8.356MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  10.58MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting   11.7MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  12.81MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  13.93MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting   15.6MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  16.71MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  17.83MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  22.28MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  27.85MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  32.31MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  36.77MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  40.67MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  44.01MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  46.79MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  50.69MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  55.71MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  59.05MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  61.28MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  62.95MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  64.62MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  66.29MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  68.52MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  71.86MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting   75.2MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  78.54MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  81.89MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  85.23MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  88.57MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  91.91MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  96.93MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  101.4MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  104.7MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  109.7MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  114.2MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  117.5MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  120.9MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  124.2MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  127.6MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  130.9MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  134.3MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting    137MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  139.3MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  141.5MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  143.2MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  148.2MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  153.2MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  162.7MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  168.2MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  173.2MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  177.1MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  179.4MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  182.7MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  185.5MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  187.7MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting    190MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  191.1MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  192.2MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Extracting  192.3MB/192.3MB\n\u001b[5B\u001b[5A\u001b[1K\u001b[K\n6f18049a0455: Pull complete \n\u001b[5B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Extracting  65.54kB/5.792MB\n\u001b[4B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Extracting  1.245MB/5.792MB\n\u001b[4B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Extracting  4.915MB/5.792MB\n\u001b[4B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Extracting  5.792MB/5.792MB\n\u001b[4B\u001b[4A\u001b[1K\u001b[K\nce39fa9d79d1: Pull complete \n\u001b[4B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting  294.9kB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting  4.424MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting  6.488MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting  9.142MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting   11.5MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting  14.16MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting  16.81MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting  20.05MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting   23.3MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting  25.95MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Extracting  26.57MB/26.57MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n3a91ffcf88ea: Pull complete \n\u001b[3B\u001b[2A\u001b[1K\u001b[K\nee82cc8e1506: Extracting     235B/235B\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\nee82cc8e1506: Extracting     235B/235B\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\nee82cc8e1506: Pull complete \n\u001b[2B\u001b[1A\u001b[1K\u001b[K\nf0fe55e0f617: Extracting  32.77kB/1.863MB\n\u001b[1B\u001b[1A\u001b[1K\u001b[K\nf0fe55e0f617: Extracting    852kB/1.863MB\n\u001b[1B\u001b[1A\u001b[1K\u001b[K\nf0fe55e0f617: Extracting  1.863MB/1.863MB\n\u001b[1B\u001b[1A\u001b[1K\u001b[K\nf0fe55e0f617: Pull complete \n\u001b[1BDigest: sha256:6eaf19442c358afc24834a6b17a3728a45c129de7703d8583392a138ecbdb092\nStatus: Downloaded newer image for python:3\n ---> 14a2caeca327\nStep 2/5 : COPY ./webserver.py /\n ---> 5b69c26def6b\nStep 3/5 : COPY ./entrypoint.sh /\n ---> 29dc01cca9f7\nStep 4/5 : WORKDIR /opt\n ---> Running in 9d8b03e3aec0\nRemoving intermediate container 9d8b03e3aec0\n ---> 75c4692e89c2\nStep 5/5 : ENTRYPOINT [\"/bin/bash\", \"/entrypoint.sh\"]\n ---> Running in c498811da89b\nRemoving intermediate container c498811da89b\n ---> 9a4e24dff624\nSuccessfully built 9a4e24dff624\nSuccessfully tagged web:latest\ntravis_time:end:027a39d4:start=1564473806933741336,finish=1564473825724013281,duration=18790271945\n\u001b[0Ktravis_fold:end:before_install.9\n\u001b[0KNo Gemfile found, skipping bundle install\n\ntravis_time:start:0922bd43\n\u001b[0K$ make $TEST_TARGET\nSending build context to Docker daemon   5.12kB\n\n\nStep 1/5 : FROM python:3\n ---> 14a2caeca327\nStep 2/5 : COPY ./webserver.py /\n ---> Using cache\n ---> 5b69c26def6b\nStep 3/5 : COPY ./entrypoint.sh /\n ---> Using cache\n ---> 29dc01cca9f7\nStep 4/5 : WORKDIR /opt\n ---> Using cache\n ---> 75c4692e89c2\nStep 5/5 : ENTRYPOINT [\"/bin/bash\", \"/entrypoint.sh\"]\n ---> Using cache\n ---> 9a4e24dff624\nSuccessfully built 9a4e24dff624\nSuccessfully tagged web:latest\nSending build context to Docker daemon  39.42kB\n\n\nStep 1/17 : FROM nginx:1.14.1\n1.14.1: Pulling from library/nginx\n\n\u001b[1A\u001b[1K\u001b[K\na5a6f2f73cd8: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\n2343eb083a4e: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\n251439d5b33c: Pulling fs layer \n\u001b[1B\u001b[1A\u001b[1K\u001b[K\n251439d5b33c: Downloading     204B/204B\n\u001b[1B\u001b[1A\u001b[1K\u001b[K\n251439d5b33c: Verifying Checksum \n\u001b[1B\u001b[1A\u001b[1K\u001b[K\n251439d5b33c: Download complete \n\u001b[1B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Downloading  229.4kB/22.49MB\n\u001b[3B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Downloading  229.4kB/22.19MB\n\u001b[2B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Downloading  8.965MB/22.49MB\n\u001b[3B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Downloading  9.206MB/22.19MB\n\u001b[2B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Downloading  21.36MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Verifying Checksum \n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Download complete \n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting  229.4kB/22.49MB\n\u001b[3B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Downloading  20.95MB/22.19MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Verifying Checksum \n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Download complete \n\u001b[2B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting  458.8kB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting  3.211MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting   7.34MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting  11.01MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting  13.53MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting  16.52MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting  19.96MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting   21.1MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting  21.56MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting  22.48MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Extracting  22.49MB/22.49MB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\na5a6f2f73cd8: Pull complete \n\u001b[3B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Extracting  229.4kB/22.19MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Extracting  4.358MB/22.19MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Extracting  8.946MB/22.19MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Extracting  13.07MB/22.19MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Extracting  16.52MB/22.19MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Extracting  20.19MB/22.19MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Extracting  22.19MB/22.19MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n2343eb083a4e: Pull complete \n\u001b[2B\u001b[1A\u001b[1K\u001b[K\n251439d5b33c: Extracting     204B/204B\n\u001b[1B\u001b[1A\u001b[1K\u001b[K\n251439d5b33c: Extracting     204B/204B\n\u001b[1B\u001b[1A\u001b[1K\u001b[K\n251439d5b33c: Pull complete \n\u001b[1BDigest: sha256:32fdf92b4e986e109e4db0865758020cb0c3b70d6ba80d02fe87bad5cc3dc228\nStatus: Downloaded newer image for nginx:1.14.1\n ---> 5f2d4477b7ea\nStep 2/17 : LABEL maintainer=\"Jason Wilder mail@jasonwilder.com\"\n ---> Running in 8b3937cb0cc8\nRemoving intermediate container 8b3937cb0cc8\n ---> 2b89c9093afc\nStep 3/17 : RUN apt-get update  && apt-get install -y -q --no-install-recommends     ca-certificates     wget  && apt-get clean  && rm -r /var/lib/apt/lists/*\n ---> Running in 0ff79fbbe996\nGet:1 http://security-cdn.debian.org/debian-security stretch/updates InRelease [94.3 kB]\nIgn:2 http://cdn-fastly.deb.debian.org/debian stretch InRelease\nGet:3 http://security-cdn.debian.org/debian-security stretch/updates/main amd64 Packages [500 kB]\nGet:4 http://cdn-fastly.deb.debian.org/debian stretch-updates InRelease [91.0 kB]\nGet:5 http://cdn-fastly.deb.debian.org/debian stretch Release [118 kB]\nGet:6 http://cdn-fastly.deb.debian.org/debian stretch Release.gpg [2434 B]\nGet:7 http://cdn-fastly.deb.debian.org/debian stretch-updates/main amd64 Packages [27.4 kB]\nGet:8 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 Packages [7082 kB]\nFetched 7915 kB in 1s (4541 kB/s)\nReading package lists...\nReading package lists...\nBuilding dependency tree...\nReading state information...\nThe following additional packages will be installed:\n  libffi6 libgmp10 libgnutls30 libhogweed4 libidn11 libidn2-0 libnettle6\n  libp11-kit0 libpsl5 libtasn1-6 libunistring0 openssl\nSuggested packages:\n  gnutls-bin\nRecommended packages:\n  publicsuffix\nThe following NEW packages will be installed:\n  ca-certificates libffi6 libgmp10 libgnutls30 libhogweed4 libidn11 libidn2-0\n  libnettle6 libp11-kit0 libpsl5 libtasn1-6 libunistring0 openssl wget\n0 upgraded, 14 newly installed, 0 to remove and 17 not upgraded.\nNeed to get 3885 kB of archives.\nAfter this operation, 10.6 MB of additional disk space will be used.\nGet:1 http://security-cdn.debian.org/debian-security stretch/updates/main amd64 openssl amd64 1.1.0k-1~deb9u1 [747 kB]\nGet:2 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libgmp10 amd64 2:6.1.2+dfsg-1 [253 kB]\nGet:3 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libnettle6 amd64 3.3-1+b2 [192 kB]\nGet:4 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libhogweed4 amd64 3.3-1+b2 [136 kB]\nGet:5 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libidn11 amd64 1.33-1 [115 kB]\nGet:6 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libffi6 amd64 3.2.1-6 [20.4 kB]\nGet:7 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libp11-kit0 amd64 0.23.3-2 [111 kB]\nGet:8 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libtasn1-6 amd64 4.10-1.1+deb9u1 [50.6 kB]\nGet:9 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libgnutls30 amd64 3.5.8-5+deb9u4 [896 kB]\nGet:10 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libunistring0 amd64 0.9.6+really0.9.3-0.1 [279 kB]\nGet:11 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libidn2-0 amd64 0.16-1+deb9u1 [60.7 kB]\nGet:12 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 libpsl5 amd64 0.17.0-3 [41.8 kB]\nGet:13 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 wget amd64 1.18-5+deb9u3 [800 kB]\nGet:14 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 ca-certificates all 20161130+nmu1+deb9u1 [182 kB]\n\u001b[91mdebconf: delaying package configuration, since apt-utils is not installed\n\u001b[0mFetched 3885 kB in 0s (7191 kB/s)\nSelecting previously unselected package libgmp10:amd64.\n\n(Reading database ... \n(Reading database ... 5%\n(Reading database ... 10%\n(Reading database ... 15%\n(Reading database ... 20%\n(Reading database ... 25%\n(Reading database ... 30%\n(Reading database ... 35%\n(Reading database ... 40%\n(Reading database ... 45%\n(Reading database ... 50%\n(Reading database ... 55%\n(Reading database ... 60%\n(Reading database ... 65%\n(Reading database ... 70%\n(Reading database ... 75%\n(Reading database ... 80%\n(Reading database ... 85%\n(Reading database ... 90%\n(Reading database ... 95%\n(Reading database ... 100%\n(Reading database ... 7026 files and directories currently installed.)\n\nPreparing to unpack .../00-libgmp10_2%3a6.1.2+dfsg-1_amd64.deb ...\n\nUnpacking libgmp10:amd64 (2:6.1.2+dfsg-1) ...\n\nSelecting previously unselected package libnettle6:amd64.\n\nPreparing to unpack .../01-libnettle6_3.3-1+b2_amd64.deb ...\n\nUnpacking libnettle6:amd64 (3.3-1+b2) ...\n\nSelecting previously unselected package libhogweed4:amd64.\n\nPreparing to unpack .../02-libhogweed4_3.3-1+b2_amd64.deb ...\n\nUnpacking libhogweed4:amd64 (3.3-1+b2) ...\n\nSelecting previously unselected package libidn11:amd64.\n\nPreparing to unpack .../03-libidn11_1.33-1_amd64.deb ...\n\nUnpacking libidn11:amd64 (1.33-1) ...\n\nSelecting previously unselected package libffi6:amd64.\n\nPreparing to unpack .../04-libffi6_3.2.1-6_amd64.deb ...\n\nUnpacking libffi6:amd64 (3.2.1-6) ...\n\nSelecting previously unselected package libp11-kit0:amd64.\n\nPreparing to unpack .../05-libp11-kit0_0.23.3-2_amd64.deb ...\n\nUnpacking libp11-kit0:amd64 (0.23.3-2) ...\n\nSelecting previously unselected package libtasn1-6:amd64.\n\nPreparing to unpack .../06-libtasn1-6_4.10-1.1+deb9u1_amd64.deb ...\n\nUnpacking libtasn1-6:amd64 (4.10-1.1+deb9u1) ...\n\nSelecting previously unselected package libgnutls30:amd64.\n\nPreparing to unpack .../07-libgnutls30_3.5.8-5+deb9u4_amd64.deb ...\n\nUnpacking libgnutls30:amd64 (3.5.8-5+deb9u4) ...\n\nSelecting previously unselected package libunistring0:amd64.\n\nPreparing to unpack .../08-libunistring0_0.9.6+really0.9.3-0.1_amd64.deb ...\n\nUnpacking libunistring0:amd64 (0.9.6+really0.9.3-0.1) ...\n\nSelecting previously unselected package libidn2-0:amd64.\n\nPreparing to unpack .../09-libidn2-0_0.16-1+deb9u1_amd64.deb ...\n\nUnpacking libidn2-0:amd64 (0.16-1+deb9u1) ...\n\nSelecting previously unselected package libpsl5:amd64.\n\nPreparing to unpack .../10-libpsl5_0.17.0-3_amd64.deb ...\n\nUnpacking libpsl5:amd64 (0.17.0-3) ...\n\nSelecting previously unselected package wget.\n\nPreparing to unpack .../11-wget_1.18-5+deb9u3_amd64.deb ...\n\nUnpacking wget (1.18-5+deb9u3) ...\n\nSelecting previously unselected package openssl.\n\nPreparing to unpack .../12-openssl_1.1.0k-1~deb9u1_amd64.deb ...\n\nUnpacking openssl (1.1.0k-1~deb9u1) ...\n\nSelecting previously unselected package ca-certificates.\n\nPreparing to unpack .../13-ca-certificates_20161130+nmu1+deb9u1_all.deb ...\n\nUnpacking ca-certificates (20161130+nmu1+deb9u1) ...\n\nSetting up libnettle6:amd64 (3.3-1+b2) ...\n\nSetting up libtasn1-6:amd64 (4.10-1.1+deb9u1) ...\n\nSetting up libgmp10:amd64 (2:6.1.2+dfsg-1) ...\n\nProcessing triggers for libc-bin (2.24-11+deb9u3) ...\n\nSetting up libunistring0:amd64 (0.9.6+really0.9.3-0.1) ...\n\nSetting up openssl (1.1.0k-1~deb9u1) ...\n\nSetting up libffi6:amd64 (3.2.1-6) ...\n\nSetting up ca-certificates (20161130+nmu1+deb9u1) ...\n\ndebconf: unable to initialize frontend: Dialog\n\ndebconf: (TERM is not set, so the dialog frontend is not usable.)\n\ndebconf: falling back to frontend: Readline\n\ndebconf: unable to initialize frontend: Readline\n\ndebconf: (Can't locate Term/ReadLine.pm in @INC (you may need to install the Term::ReadLine module) (@INC contains: /etc/perl /usr/local/lib/x86_64-linux-gnu/perl/5.24.1 /usr/local/share/perl/5.24.1 /usr/lib/x86_64-linux-gnu/perl5/5.24 /usr/share/perl5 /usr/lib/x86_64-linux-gnu/perl/5.24 /usr/share/perl/5.24 /usr/local/lib/site_perl /usr/lib/x86_64-linux-gnu/perl-base .) at /usr/share/perl5/Debconf/FrontEnd/Readline.pm line 7.)\n\ndebconf: falling back to frontend: Teletype\n\nUpdating certificates in /etc/ssl/certs...\n\n151 added, 0 removed; done.\n\nSetting up libidn11:amd64 (1.33-1) ...\n\nSetting up libidn2-0:amd64 (0.16-1+deb9u1) ...\n\nSetting up libpsl5:amd64 (0.17.0-3) ...\n\nSetting up libhogweed4:amd64 (3.3-1+b2) ...\n\nSetting up libp11-kit0:amd64 (0.23.3-2) ...\n\nSetting up libgnutls30:amd64 (3.5.8-5+deb9u4) ...\n\nSetting up wget (1.18-5+deb9u3) ...\n\nProcessing triggers for libc-bin (2.24-11+deb9u3) ...\n\nProcessing triggers for ca-certificates (20161130+nmu1+deb9u1) ...\n\nUpdating certificates in /etc/ssl/certs...\n\n0 added, 0 removed; done.\n\nRunning hooks in /etc/ca-certificates/update.d...\n\ndone.\n\nRemoving intermediate container 0ff79fbbe996\n ---> 0ac4cd2c6647\nStep 4/17 : RUN echo \"daemon off;\" >> /etc/nginx/nginx.conf  && sed -i 's/worker_processes  1/worker_processes  auto/' /etc/nginx/nginx.conf\n ---> Running in 972c101b4b71\nRemoving intermediate container 972c101b4b71\n ---> cb166008346e\nStep 5/17 : ADD https://github.com/jwilder/forego/releases/download/v0.16.1/forego /usr/local/bin/forego\n\u001b[1K\u001b[K\nDownloading    103kB/9.763MB\n\u001b[1K\u001b[K\nDownloading  1.147MB/9.763MB\n\u001b[1K\u001b[K\nDownloading  7.177MB/9.763MB\n\u001b[1K\u001b[K\nDownloading  9.763MB/9.763MB\n\n ---> df51b4bddae7\nStep 6/17 : RUN chmod u+x /usr/local/bin/forego\n ---> Running in de3f53674d67\nRemoving intermediate container de3f53674d67\n ---> 05c5e8e37a02\nStep 7/17 : ENV DOCKER_GEN_VERSION 0.7.4\n ---> Running in 580ab2b9aff2\nRemoving intermediate container 580ab2b9aff2\n ---> 0718093c4bfe\nStep 8/17 : RUN wget https://github.com/jwilder/docker-gen/releases/download/$DOCKER_GEN_VERSION/docker-gen-linux-amd64-$DOCKER_GEN_VERSION.tar.gz  && tar -C /usr/local/bin -xvzf docker-gen-linux-amd64-$DOCKER_GEN_VERSION.tar.gz  && rm /docker-gen-linux-amd64-$DOCKER_GEN_VERSION.tar.gz\n ---> Running in 76f91346deba\n\u001b[91m--2019-07-30 08:04:04--  https://github.com/jwilder/docker-gen/releases/download/0.7.4/docker-gen-linux-amd64-0.7.4.tar.gz\n\u001b[0m\u001b[91mResolving github.com (github.com)... \u001b[0m\u001b[91m140.82.114.3\nConnecting to github.com (github.com)|140.82.114.3|:443... \u001b[0m\u001b[91mconnected.\n\u001b[0m\u001b[91mHTTP request sent, awaiting response... \u001b[0m\u001b[91m302 Found\n\u001b[0m\u001b[91mLocation: https://github-production-release-asset-2e65be.s3.amazonaws.com/17762549/9bf348a6-f93a-11e7-9ff0-34e8263a4acb?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20190730%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20190730T080404Z&X-Amz-Expires=300&X-Amz-Signature=54089c900677ae87c1882335c1acd663da095a4f54842b3f40848b1dab80b007&X-Amz-SignedHeaders=host&actor_id=0&response-content-disposition=attachment%3B%20filename%3Ddocker-gen-linux-amd64-0.7.4.tar.gz&response-content-type=application%2Foctet-stream [following]\n\u001b[0m\u001b[91m--2019-07-30 08:04:04--  https://github-production-release-asset-2e65be.s3.amazonaws.com/17762549/9bf348a6-f93a-11e7-9ff0-34e8263a4acb?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20190730%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20190730T080404Z&X-Amz-Expires=300&X-Amz-Signature=54089c900677ae87c1882335c1acd663da095a4f54842b3f40848b1dab80b007&X-Amz-SignedHeaders=host&actor_id=0&response-content-disposition=attachment%3B%20filename%3Ddocker-gen-linux-amd64-0.7.4.tar.gz&response-content-type=application%2Foctet-stream\n\u001b[0m\u001b[91mResolving github-production-release-asset-2e65be.s3.amazonaws.com (github-production-release-asset-2e65be.s3.amazonaws.com)... \u001b[0m\u001b[91m52.217.37.140\nConnecting to github-production-release-asset-2e65be.s3.amazonaws.com (github-production-release-asset-2e65be.s3.amazonaws.com)|52.217.37.140|:443... \u001b[0m\u001b[91mconnected.\n\u001b[0m\u001b[91mHTTP request sent, awaiting response... \u001b[0m\u001b[91m200 OK\n\u001b[0m\u001b[91mLength: 3424683 (3.3M) [application/octet-stream]\n\u001b[0m\u001b[91mSaving to: 'docker-gen-linux-amd64-0.7.4.tar.gz'\n\u001b[0m\u001b[91m\n     0K .......... ......\u001b[0m\u001b[91m.... .......... ...\u001b[0m\u001b[91m....... ..........  1%\u001b[0m\u001b[91m 1.50M 2s\u001b[0m\u001b[91m\n    50K .......... .......\u001b[0m\u001b[91m... .......... .......... ..........  2% 1.51M 2s\n   100K .......... ........\u001b[0m\u001b[91m.. .......... ....\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.. ...\u001b[0m\u001b[91m.......  4% 1.47M 2s\n   150K .\u001b[0m\u001b[91m......... .......... .......... .......... ..........  5%  121M 2s\n   200K ...\u001b[0m\u001b[91m..\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m. \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m... \u001b[0m\u001b[91m.\u001b[0m\u001b[91m....\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m  7%\u001b[0m\u001b[91m 31.7M\u001b[0m\u001b[91m 1s\u001b[0m\u001b[91m\n   250K\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.. ..........  8% 1.51M 1s\n   300K ....\u001b[0m\u001b[91m.\u001b[0m\u001b[91m..... .......... .\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.....\u001b[0m\u001b[91m .........\u001b[0m\u001b[91m. .......\u001b[0m\u001b[91m... 10% 38.5M 1s\n   350K .......\u001b[0m\u001b[91m... .......... ...\u001b[0m\u001b[91m....... .......... .\u001b[0m\u001b[91m......... 11%  102M 1s\n   400K ......\u001b[0m\u001b[91m.\u001b[0m\u001b[91m... .......... .......... ..........\u001b[0m\u001b[91m .......... 13%  111M 1s\n   450K ........\u001b[0m\u001b[91m.. .......... .......... .......... .......... 14%  152M 1s\n   500K .........\u001b[0m\u001b[91m. .......... ......\u001b[0m\u001b[91m.... .......... .......... 16% 1.62M 1s\n   550K .......... .......... .......... .......... ....\u001b[0m\u001b[91m...... 17%  168M 1s\n   600K .......... .......... .......... .......... .......... 19%  189M 1s\n   650K .......... .......... .......... .......\u001b[0m\u001b[91m...\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m..\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m....\u001b[0m\u001b[91m 20% 71.5M 1s\n   700K ........\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m...\u001b[0m\u001b[91m.\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m..\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.. \u001b[0m\u001b[91m.......\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m 22%\u001b[0m\u001b[91m 24.2M\u001b[0m\u001b[91m 1s\u001b[0m\u001b[91m\n   750K\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m...... .\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m .\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m...\u001b[0m\u001b[91m. .......\u001b[0m\u001b[91m.\u001b[0m\u001b[91m..\u001b[0m\u001b[91m 23%\u001b[0m\u001b[91m 25.3M 1s\n   800K .......... ..\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.....\u001b[0m\u001b[91m..\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m......... ..\u001b[0m\u001b[91m........ ..\u001b[0m\u001b[91m..\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m...\u001b[0m\u001b[91m. 25% 48.7M\u001b[0m\u001b[91m 1s\u001b[0m\u001b[91m\n   850K .......\u001b[0m\u001b[91m... ......\u001b[0m\u001b[91m.... .......... ...\u001b[0m\u001b[91m....... .\u001b[0m\u001b[91m......... 26% 13.4M\u001b[0m\u001b[91m 0s\u001b[0m\u001b[91m\n   900K .......... ......\u001b[0m\u001b[91m.\u001b[0m\u001b[91m... .....\u001b[0m\u001b[91m..... ....\u001b[0m\u001b[91m...... ..\u001b[0m\u001b[91m........ 28%  281M 0s\u001b[0m\u001b[91m\n   950K .........\u001b[0m\u001b[91m. ........\u001b[0m\u001b[91m.. ....\u001b[0m\u001b[91m...... .....\u001b[0m\u001b[91m..... ...\u001b[0m\u001b[91m....... 29%  274M 0s\n  1000K .\u001b[0m\u001b[91m.........\u001b[0m\u001b[91m .........\u001b[0m\u001b[91m. ..\u001b[0m\u001b[91m........ ......\u001b[0m\u001b[91m.... ....\u001b[0m\u001b[91m...... 31%  285M 0s\n  1050K ..\u001b[0m\u001b[91m.\u001b[0m\u001b[91m....... .......... .......... .......\u001b[0m\u001b[91m... .......... 32% 2.18M 0s\n  1100K ......\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m. .......... .......... .......\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.. 34% 40.3M 0s\n  1150K .......... .......... .\u001b[0m\u001b[91m......... ........\u001b[0m\u001b[91m.. .......... 35%  101M 0s\n  1200K .......... ......\u001b[0m\u001b[91m.... .......... .......... .......... 37%  156M\u001b[0m\u001b[91m 0s\n  1250K .......... .......... ....\u001b[0m\u001b[91m...... ..\u001b[0m\u001b[91m.\u001b[0m\u001b[91m....... .........\u001b[0m\u001b[91m. 38% 98.7M 0s\n  1300K ...\u001b[0m\u001b[91m..\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m. ....\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m... ....\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.... .\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.. .......\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.. 40% 34.2M 0s\u001b[0m\u001b[91m\n  1350K ........\u001b[0m\u001b[91m.. .......\u001b[0m\u001b[91m... .......... .......... .......... 41% 82.9M 0s\n  1400K .......\u001b[0m\u001b[91m... .......... ...\u001b[0m\u001b[91m....... .......... .......... 43%  147M 0s\n  1450K .......... .......... .\u001b[0m\u001b[91m......... .......... .......... 44%  247M 0s\n  1500K .......... .......... ........\u001b[0m\u001b[91m.. .......... .......... 46%  198M 0s\n  1550K .\u001b[0m\u001b[91m......... .......... .......... ...\u001b[0m\u001b[91m....... .........\u001b[0m\u001b[91m. 47% 1.82M 0s\n  1600K .......... .......... .......... .\u001b[0m\u001b[91m......... .......... 49%  123M 0s\n  1650K .......... .......... .\u001b[0m\u001b[91m......... .......... .....\u001b[0m\u001b[91m..... 50%  164M 0s\n  1700K ..\u001b[0m\u001b[91m........ .\u001b[0m\u001b[91m......... .......... .......... .......... 52%  204M 0s\n  1750K .......... .......... .......... .......... .......... 53%\u001b[0m\u001b[91m  133M 0s\n  1800K .......\u001b[0m\u001b[91m... .......... .......... .\u001b[0m\u001b[91m........\u001b[0m\u001b[91m. ........\u001b[0m\u001b[91m.. 55%  117M 0s\n  1850K .....\u001b[0m\u001b[91m.....\u001b[0m\u001b[91m \u001b[0m\u001b[91m.\u001b[0m\u001b[91m..\u001b[0m\u001b[91m.\u001b[0m\u001b[91m....\u001b[0m\u001b[91m.\u001b[0m\u001b[91m.\u001b[0m\u001b[91m .\u001b[0m\u001b[91m.........\u001b[0m\u001b[91m .\u001b[0m\u001b[91m......\u001b[0m\u001b[91m... .....\u001b[0m\u001b[91m..... 56%\u001b[0m\u001b[91m 42.6M 0s\n  1900K ...\u001b[0m\u001b[91m.......\u001b[0m\u001b[91m .\u001b[0m\u001b[91m......\u001b[0m\u001b[91m..\u001b[0m\u001b[91m. .......... .....\u001b[0m\u001b[91m..... .......... 58% 74.5M 0s\n  1950K .\u001b[0m\u001b[91m......... .......\u001b[0m\u001b[91m... .......... .......... .........\u001b[0m\u001b[91m. 59%  153M 0s\n  2000K .......... .......... .......... .........\u001b[0m\u001b[91m. .......... 61%  160M 0s\n  2050K .......... ...\u001b[0m\u001b[91m....... .......... .......... .......... 62%  195M 0s\n  2100K .......... .......... .......... .......... ...\u001b[0m\u001b[91m....... 64%  159M 0s\n  2150K .......... .......... .......... .......... .\u001b[0m\u001b[91m......... 65%  173M 0s\n  2200K .......... .......... .......... .......... .......... 67%  322M 0s\n  2250K .....\u001b[0m\u001b[91m..... .......... .......... .......... .......... 68%  198M 0s\n  2300K .......... .........\u001b[0m\u001b[91m. .......... .......... .......... 70%  319M 0s\n  2350K .......... .......\u001b[0m\u001b[91m... .......... .......... .......... 71%  190M 0s\n  2400K .......... .....\u001b[0m\u001b[91m..... .......... .......... .......... 73%  271M 0s\n  2450K ......\u001b[0m\u001b[91m.... .......... .......... .......... .....\u001b[0m\u001b[91m..... 74%  243M 0s\n  2500K .......... .......... .......... .......... ...\u001b[0m\u001b[91m....... 76%  230M 0s\n  2550K .......... .......... .......... .......... .\u001b[0m\u001b[91m......... 77%  279M 0s\n  2600K .......... .......... .......... .........\u001b[0m\u001b[91m. .......... 79%  200M 0s\n  2650K .......... .......... .\u001b[0m\u001b[91m......... .......... .......... 80%  228M 0s\n  2700K .......... .\u001b[0m\u001b[91m......... .......... .......... .......... 82%  254M 0s\n  2750K .......... ..\u001b[0m\u001b[91m........ .......... .......... .......... 83%  214M 0s\n  2800K .......... .....\u001b[0m\u001b[91m..... .......... .......... .......... 85%  264M 0s\n  2850K .......... ...\u001b[0m\u001b[91m....... .......... .......... .......... 86%  257M 0s\n  2900K .......... .....\u001b[0m\u001b[91m..... .......... .......... .......... 88%  210M 0s\n  2950K .\u001b[0m\u001b[91m......... .......... .......... .......... .......... 89%  217M 0s\n  3000K .......... .......... ...\u001b[0m\u001b[91m....... .......... .......... 91%  241M 0s\n  3050K .......... .......... .\u001b[0m\u001b[91m......... .......... .......... 92%  310M 0s\n  3100K .......... .......... .......\u001b[0m\u001b[91m... .......... .......... 94%  212M 0s\n  3150K .......... .\u001b[0m\u001b[91m......\u001b[0m\u001b[91m... .......... .......... .......... 95% 2.08M 0s\n  3200K .......... .......... .......... .\u001b[0m\u001b[91m......... .......... 97%  103M 0s\n  3250K .......... .......... .......... ...\u001b[0m\u001b[91m....... .......... 98%  260M 0s\n  3300K .......... .......... .......\u001b[0m\u001b[91m... .......... ....      100%  173M=0.3s\n\n\u001b[0m\u001b[91m2019-07-30 08:04:04 (12.4 MB/s) - 'docker-gen-linux-amd64-0.7.4.tar.gz' saved [3424683/3424683]\n\n\u001b[0mdocker-gen\nRemoving intermediate container 76f91346deba\n ---> 4f21a5cb312f\nStep 9/17 : COPY network_internal.conf /etc/nginx/\n ---> d8251120d14b\nStep 10/17 : COPY . /app/\n ---> f467c4c977bc\nStep 11/17 : WORKDIR /app/\n ---> Running in fe6e38d81ad5\nRemoving intermediate container fe6e38d81ad5\n ---> ef15bac7dca8\nStep 12/17 : RUN touch /app/htpasswd_generator.sh && chmod +x /app/htpasswd_generator.sh\n ---> Running in 58e9c248959a\nRemoving intermediate container 58e9c248959a\n ---> 17fd53484067\nStep 13/17 : ENV DOCKER_HOST unix:///tmp/docker.sock\n ---> Running in 2707808b35fa\nRemoving intermediate container 2707808b35fa\n ---> 513c5ab89454\nStep 14/17 : ENV RESOLVERS=\"127.0.0.11 valid=5s\"\n ---> Running in b5dca319d75b\nRemoving intermediate container b5dca319d75b\n ---> c3956952a051\nStep 15/17 : VOLUME [\"/etc/nginx/certs\", \"/etc/nginx/dhparam\"]\n ---> Running in 18266381562a\nRemoving intermediate container 18266381562a\n ---> 21d5ff440ff8\nStep 16/17 : ENTRYPOINT [\"/app/docker-entrypoint.sh\"]\n ---> Running in 49b0184329d7\nRemoving intermediate container 49b0184329d7\n ---> f0598ca57393\nStep 17/17 : CMD [\"forego\", \"start\", \"-r\"]\n ---> Running in e1465bda7369\nRemoving intermediate container e1465bda7369\n ---> e4a116d37365\nSuccessfully built e4a116d37365\nSuccessfully tagged jwilder/nginx-proxy:test\n> Building nginx-proxy-tester image...\nSending build context to Docker daemon  11.26kB\n\n\nStep 1/6 : FROM python:2.7-alpine\n2.7-alpine: Pulling from library/python\n\n\u001b[1A\u001b[1K\u001b[K\n050382585609: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\n39e8b6a82737: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\n9c3480ede676: Pulling fs layer \n\u001b[1B\n\u001b[1A\u001b[1K\u001b[K\n7a50c76dc4da: Pulling fs layer \n\u001b[1B\u001b[1A\u001b[1K\u001b[K\n7a50c76dc4da: Waiting \n\u001b[1B\u001b[3A\u001b[1K\u001b[K\n39e8b6a82737: Downloading  3.222kB/301.7kB\n\u001b[3B\u001b[4A\u001b[1K\u001b[K\n050382585609: Downloading  29.23kB/2.79MB\n\u001b[4B\u001b[3A\u001b[1K\u001b[K\n39e8b6a82737: Downloading  301.7kB/301.7kB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n39e8b6a82737: Verifying Checksum \n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n39e8b6a82737: Download complete \n\u001b[3B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Downloading  184.1kB/18.35MB\n\u001b[2B\u001b[4A\u001b[1K\u001b[K\n050382585609: Verifying Checksum \n\u001b[4B\u001b[4A\u001b[1K\u001b[K\n050382585609: Download complete \n\u001b[4B\u001b[4A\u001b[1K\u001b[K\n050382585609: Extracting  32.77kB/2.79MB\n\u001b[4B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Downloading  8.563MB/18.35MB\n\u001b[2B\u001b[4A\u001b[1K\u001b[K\n050382585609: Extracting    852kB/2.79MB\n\u001b[4B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Downloading  17.79MB/18.35MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Verifying Checksum \n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Download complete \n\u001b[2B\u001b[4A\u001b[1K\u001b[K\n050382585609: Extracting   2.79MB/2.79MB\n\u001b[4B\u001b[1A\u001b[1K\u001b[K\n7a50c76dc4da: Downloading  19.81kB/1.86MB\n\u001b[1B\u001b[4A\u001b[1K\u001b[K\n050382585609: Pull complete \n\u001b[4B\u001b[3A\u001b[1K\u001b[K\n39e8b6a82737: Extracting  32.77kB/301.7kB\n\u001b[3B\u001b[1A\u001b[1K\u001b[K\n7a50c76dc4da: Verifying Checksum \n\u001b[1B\u001b[1A\u001b[1K\u001b[K\n7a50c76dc4da: Download complete \n\u001b[1B\u001b[3A\u001b[1K\u001b[K\n39e8b6a82737: Extracting  301.7kB/301.7kB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n39e8b6a82737: Extracting  301.7kB/301.7kB\n\u001b[3B\u001b[3A\u001b[1K\u001b[K\n39e8b6a82737: Pull complete \n\u001b[3B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Extracting  196.6kB/18.35MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Extracting  2.359MB/18.35MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Extracting  5.505MB/18.35MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Extracting   9.83MB/18.35MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Extracting  12.98MB/18.35MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Extracting  15.93MB/18.35MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Extracting  17.89MB/18.35MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Extracting  18.28MB/18.35MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Extracting  18.35MB/18.35MB\n\u001b[2B\u001b[2A\u001b[1K\u001b[K\n9c3480ede676: Pull complete \n\u001b[2B\u001b[1A\u001b[1K\u001b[K\n7a50c76dc4da: Extracting  32.77kB/1.86MB\n\u001b[1B\u001b[1A\u001b[1K\u001b[K\n7a50c76dc4da: Extracting  786.4kB/1.86MB\n\u001b[1B\u001b[1A\u001b[1K\u001b[K\n7a50c76dc4da: Extracting   1.86MB/1.86MB\n\u001b[1B\u001b[1A\u001b[1K\u001b[K\n7a50c76dc4da: Pull complete \n\u001b[1BDigest: sha256:c17fe9d9be5a545a52f00a1e9258f83ceed4484fb986f37ca019e55a24b28271\nStatus: Downloaded newer image for python:2.7-alpine\n ---> f101ac3346a7\nStep 2/6 : RUN apk add --update bash openssl curl && rm -rf /var/cache/apk/*\n ---> Running in 3b4baefc992a\nfetch http://dl-cdn.alpinelinux.org/alpine/v3.10/main/x86_64/APKINDEX.tar.gz\nfetch http://dl-cdn.alpinelinux.org/alpine/v3.10/community/x86_64/APKINDEX.tar.gz\n(1/5) Installing bash (5.0.0-r0)\nExecuting bash-5.0.0-r0.post-install\n(2/5) Installing nghttp2-libs (1.38.0-r0)\n(3/5) Installing libcurl (7.65.1-r0)\n(4/5) Installing curl (7.65.1-r0)\n(5/5) Installing openssl (1.1.1c-r0)\nExecuting busybox-1.30.1-r2.trigger\nOK: 20 MiB in 38 packages\nRemoving intermediate container 3b4baefc992a\n ---> 1ba575329cf8\nStep 3/6 : COPY python-requirements.txt /requirements.txt\n ---> ea54f1130bb4\nStep 4/6 : RUN pip install -r /requirements.txt\n ---> Running in 9d9720367b00\n\u001b[91mDEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won't be maintained after that date. A future version of pip will drop support for Python 2.7. More details about Python 2 support in pip, can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support\n\u001b[0mCollecting backoff==1.3.2 (from -r /requirements.txt (line 1))\n  Downloading https://files.pythonhosted.org/packages/7a/ba/5786dfda66ee5e4d1fe09164a1e52c68cdb93205c81b8c0f22b4ccb1a1e7/backoff-1.3.2.tar.gz\nCollecting docker-compose==1.11.2 (from -r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/66/d4/2b69141a0b5e685659891c04748bbb414bef67c79a46333d915fbda3731d/docker_compose-1.11.2-py2.py3-none-any.whl (85kB)\nCollecting docker==2.1.0 (from -r /requirements.txt (line 3))\n  Downloading https://files.pythonhosted.org/packages/42/67/415e39720bfc3ddcb07eb7007598b0f301246c168d3ac0e8cb5a625a1f9c/docker-2.1.0-py2.py3-none-any.whl (105kB)\nCollecting pytest==3.0.5 (from -r /requirements.txt (line 4))\n  Downloading https://files.pythonhosted.org/packages/dd/28/4abc547194d8e6ff93d3ef186cb809a413d719cdc21e524af08fe986f7c2/pytest-3.0.5-py2.py3-none-any.whl (170kB)\nCollecting requests==2.11.1 (from -r /requirements.txt (line 5))\n  Downloading https://files.pythonhosted.org/packages/ea/03/92d3278bf8287c5caa07dbd9ea139027d5a3592b0f4d14abf072f890fab2/requests-2.11.1-py2.py3-none-any.whl (514kB)\nCollecting PyYAML<4,>=3.10 (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/9e/a3/1d13970c3f36777c583f136c136f804d70f500168edc1edea6daa7200769/PyYAML-3.13.tar.gz (270kB)\nCollecting backports.ssl-match-hostname>=3.5; python_version < \"3.5\" (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/ff/2b/8265224812912bc5b7a607c44bf7b027554e1b9775e9ee0de8032e3de4b2/backports.ssl_match_hostname-3.7.0.1.tar.gz\nCollecting dockerpty<0.5,>=0.4.1 (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/8d/ee/e9ecce4c32204a6738e0a5d5883d3413794d7498fe8b06f44becc028d3ba/dockerpty-0.4.1.tar.gz\nCollecting six<2,>=1.3.0 (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/73/fb/00a976f728d0d1fecfe898238ce23f502a721c0ac0ecfedb80e0d88c64e9/six-1.12.0-py2.py3-none-any.whl\nCollecting enum34<2,>=1.0.4; python_version < \"3.4\" (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/c5/db/e56e6b4bbac7c4a06de1c50de6fe1ef3810018ae11732a50f15f62c7d050/enum34-1.1.6-py2-none-any.whl\nCollecting colorama<0.4,>=0.3.7 (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/db/c8/7dcf9dbcb22429512708fe3a547f8b6101c0d02137acbd892505aee57adf/colorama-0.3.9-py2.py3-none-any.whl\nCollecting ipaddress>=1.0.16; python_version < \"3.3\" (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/fc/d0/7fc3a811e011d4b388be48a0e381db8d990042df54aa4ef4599a31d39853/ipaddress-1.0.22-py2.py3-none-any.whl\nCollecting websocket-client<1.0,>=0.32.0 (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/29/19/44753eab1fdb50770ac69605527e8859468f3c0fd7dc5a76dd9c4dbd7906/websocket_client-0.56.0-py2.py3-none-any.whl (200kB)\nCollecting cached-property<2,>=1.2.0 (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/3b/86/85c1be2e8db9e13ef9a350aecd6dea292bd612fa288c2f40d035bb750ded/cached_property-1.5.1-py2.py3-none-any.whl\nCollecting docopt<0.7,>=0.6.1 (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/a2/55/8f8cab2afd404cf578136ef2cc5dfb50baa1761b68c9da1fb1e4eed343c9/docopt-0.6.2.tar.gz\nCollecting jsonschema<3,>=2.5.1 (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/77/de/47e35a97b2b05c2fadbec67d44cfcdcd09b8086951b331d82de90d2912da/jsonschema-2.6.0-py2.py3-none-any.whl\nCollecting texttable<0.9,>=0.8.1 (from docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/74/49/23d944a6f7d4dd20846b2df2914fe108c96a253567c140c416edbf270f80/texttable-0.8.8.tar.gz\nCollecting docker-pycreds>=0.2.1 (from docker==2.1.0->-r /requirements.txt (line 3))\n  Downloading https://files.pythonhosted.org/packages/f5/e8/f6bd1eee09314e7e6dee49cbe2c5e22314ccdb38db16c9fc72d2fa80d054/docker_pycreds-0.4.0-py2.py3-none-any.whl\nCollecting py>=1.4.29 (from pytest==3.0.5->-r /requirements.txt (line 4))\n  Downloading https://files.pythonhosted.org/packages/76/bc/394ad449851729244a97857ee14d7cba61ddb268dce3db538ba2f2ba1f0f/py-1.8.0-py2.py3-none-any.whl (83kB)\nCollecting functools32; python_version == \"2.7\" (from jsonschema<3,>=2.5.1->docker-compose==1.11.2->-r /requirements.txt (line 2))\n  Downloading https://files.pythonhosted.org/packages/c5/60/6ac26ad05857c601308d8fb9e87fa36d0ebf889423f47c3502ef034365db/functools32-3.2.3-2.tar.gz\nBuilding wheels for collected packages: backoff, PyYAML, backports.ssl-match-hostname, dockerpty, docopt, texttable, functools32\n  Building wheel for backoff (setup.py): started\n  Building wheel for backoff (setup.py): finished with status 'done'\n  Created wheel for backoff: filename=backoff-1.3.2-cp27-none-any.whl size=7482 sha256=77aa4184365ffc2766d8b03ba1dae77e2eb6f3284673995a64f4fd2e41190c8b\n  Stored in directory: /root/.cache/pip/wheels/fc/d8/34/d2bccc8e1a15f611dbd606c69e5d027b62dfcf922fdf8e396d\n  Building wheel for PyYAML (setup.py): started\n  Building wheel for PyYAML (setup.py): finished with status 'done'\n  Created wheel for PyYAML: filename=PyYAML-3.13-cp27-cp27mu-linux_x86_64.whl size=43810 sha256=31f5d1643186ccd14d344db29e1ef198e474189f850658b71e6dd6082f64c82c\n  Stored in directory: /root/.cache/pip/wheels/ad/da/0c/74eb680767247273e2cf2723482cb9c924fe70af57c334513f\n  Building wheel for backports.ssl-match-hostname (setup.py): started\n  Building wheel for backports.ssl-match-hostname (setup.py): finished with status 'done'\n  Created wheel for backports.ssl-match-hostname: filename=backports.ssl_match_hostname-3.7.0.1-py2.py3-none-any.whl size=6738 sha256=1871907e007834fb9800b82ba3e772078959b0babe1e8b8e4e12dd0c1795aef3\n  Stored in directory: /root/.cache/pip/wheels/f1/ad/d7/c184cf1ef67b07f98565dc52f91ed4f9a759b7b46674b2fd76\n  Building wheel for dockerpty (setup.py): started\n  Building wheel for dockerpty (setup.py): finished with status 'done'\n  Created wheel for dockerpty: filename=dockerpty-0.4.1-cp27-none-any.whl size=16606 sha256=179a8a8949a293ecbf835f4f9bad362f70f7a63e00a3070a9be18fc4fd2d672d\n  Stored in directory: /root/.cache/pip/wheels/e5/1e/86/bd0a97a0907c6c654af654d5875d1d4383dd1f575f77cee4aa\n  Building wheel for docopt (setup.py): started\n  Building wheel for docopt (setup.py): finished with status 'done'\n  Created wheel for docopt: filename=docopt-0.6.2-py2.py3-none-any.whl size=13704 sha256=22f582d90355cf6eeebfbbd9269c7760728337bcd9e6bafc17e8bc722ec21fb7\n  Stored in directory: /root/.cache/pip/wheels/9b/04/dd/7daf4150b6d9b12949298737de9431a324d4b797ffd63f526e\n  Building wheel for texttable (setup.py): started\n  Building wheel for texttable (setup.py): finished with status 'done'\n  Created wheel for texttable: filename=texttable-0.8.8-cp27-none-any.whl size=9810 sha256=a4f4b11aac7c87e7361d0521e27e3dfe4d04da87a5c1ab7688b77020006b9e04\n  Stored in directory: /root/.cache/pip/wheels/e6/50/66/cffbd36db351677a36e03cc8f071e519cbf6a907ef9bad117d\n  Building wheel for functools32 (setup.py): started\n  Building wheel for functools32 (setup.py): finished with status 'done'\n  Created wheel for functools32: filename=functools32-3.2.3.post2-cp27-none-any.whl size=14558 sha256=dd9520d66641e07a5b44479583fd57c5a4bc1babba5d11b8b97044f47ee6b593\n  Stored in directory: /root/.cache/pip/wheels/b5/18/32/77a1030457155606ba5e3ec3a8a57132b1a04b1c4f765177b2\nSuccessfully built backoff PyYAML backports.ssl-match-hostname dockerpty docopt texttable functools32\nInstalling collected packages: backoff, PyYAML, six, websocket-client, requests, backports.ssl-match-hostname, ipaddress, docker-pycreds, docker, dockerpty, enum34, colorama, cached-property, docopt, functools32, jsonschema, texttable, docker-compose, py, pytest\nSuccessfully installed PyYAML-3.13 backoff-1.3.2 backports.ssl-match-hostname-3.7.0.1 cached-property-1.5.1 colorama-0.3.9 docker-2.1.0 docker-compose-1.11.2 docker-pycreds-0.4.0 dockerpty-0.4.1 docopt-0.6.2 enum34-1.1.6 functools32-3.2.3.post2 ipaddress-1.0.22 jsonschema-2.6.0 py-1.8.0 pytest-3.0.5 requests-2.11.1 six-1.12.0 texttable-0.8.8 websocket-client-0.56.0\nRemoving intermediate container 9d9720367b00\n ---> f72e9255e70e\nStep 5/6 : WORKDIR /test\n ---> Running in 09564099681b\nRemoving intermediate container 09564099681b\n ---> 4ffc0b7dd753\nStep 6/6 : ENTRYPOINT [\"pytest\"]\n ---> Running in 30d4fad73d95\nRemoving intermediate container 30d4fad73d95\n ---> a984dbc1899b\nSuccessfully built a984dbc1899b\nSuccessfully tagged nginx-proxy-tester:latest\n\u001b[1m============================= test session starts ==============================\u001b[0m\nplatform linux2 -- Python 2.7.16, pytest-3.0.5, py-1.8.0, pluggy-0.4.0 -- /usr/local/bin/python\nrootdir: /home/travis/build/jwilder/nginx-proxy/test, inifile: pytest.ini\n\u001b[1m\ncollecting 0 items\u001b[0m\u001b[1m\ncollecting 3 items\u001b[0m\u001b[1m\ncollecting 5 items\u001b[0m\u001b[1m\ncollecting 6 items\u001b[0m\u001b[1m\ncollecting 8 items\u001b[0m\u001b[1m\ncollecting 14 items\u001b[0m\u001b[1m\ncollecting 17 items\u001b[0m\u001b[1m\ncollecting 20 items\u001b[0m\u001b[1m\ncollecting 24 items\u001b[0m\u001b[1m\ncollecting 40 items\u001b[0m\u001b[1m\ncollecting 47 items\u001b[0m\u001b[1m\ncollecting 52 items\u001b[0m\u001b[1m\ncollecting 56 items\u001b[0m\u001b[1m\ncollecting 59 items\u001b[0m\u001b[1m\ncollecting 63 items\u001b[0m\u001b[1m\ncollecting 66 items\u001b[0m\u001b[1m\ncollecting 69 items\u001b[0m\u001b[1m\ncollecting 71 items\u001b[0m\u001b[1m\ncollecting 73 items\u001b[0m\u001b[1m\ncollecting 85 items\u001b[0m\u001b[1m\ncollecting 97 items\u001b[0m\u001b[1m\ncollecting 98 items\u001b[0m\u001b[1m\ncollecting 99 items\u001b[0m\u001b[1m\ncollecting 100 items\u001b[0m\u001b[1m\ncollecting 103 items\u001b[0m\u001b[1m\ncollecting 104 items\u001b[0m\u001b[1m\ncollecting 109 items\u001b[0m\u001b[1m\ncollecting 112 items\u001b[0m\u001b[1m\ncollecting 114 items\u001b[0m\u001b[1m\ncollecting 117 items\u001b[0m\u001b[1m\ncollecting 123 items\u001b[0m\u001b[1m\ncollecting 129 items\u001b[0m\u001b[1m\ncollected 129 items \n\u001b[0m\ntest_DOCKER_HOST_unix_socket.py::test_unknown_virtual_host \u001b[31mFAILED\u001b[0m\ntest_DOCKER_HOST_unix_socket.py::test_forwards_to_web1 \u001b[31mFAILED\u001b[0m\ntest_DOCKER_HOST_unix_socket.py::test_forwards_to_web2 \u001b[31mFAILED\u001b[0m\ntest_composev2.py::test_unknown_virtual_host \u001b[31mFAILED\u001b[0m\ntest_composev2.py::test_forwards_to_whoami \u001b[31mFAILED\u001b[0m\ntest_default-host.py::test_fallback_on_default \u001b[31mFAILED\u001b[0m\ntest_events.py::test_nginx_proxy_behavior_when_alone \u001b[31mFAILED\u001b[0m\ntest_events.py::test_new_container_is_detected \u001b[31mFAILED\u001b[0m\ntest_ipv6.py::test_unknown_virtual_host_ipv4 \u001b[31mFAILED\u001b[0m\ntest_ipv6.py::test_forwards_to_web1_ipv4 \u001b[31mFAILED\u001b[0m\ntest_ipv6.py::test_forwards_to_web2_ipv4 \u001b[31mFAILED\u001b[0m\ntest_ipv6.py::test_unknown_virtual_host_ipv6 \u001b[31mFAILED\u001b[0m\ntest_ipv6.py::test_forwards_to_web1_ipv6 \u001b[31mFAILED\u001b[0m\ntest_ipv6.py::test_forwards_to_web2_ipv6 \u001b[31mFAILED\u001b[0m\ntest_multiple-hosts.py::test_unknown_virtual_host_is_503 \u001b[31mFAILED\u001b[0m\ntest_multiple-hosts.py::test_webA_is_forwarded \u001b[31mFAILED\u001b[0m\ntest_multiple-hosts.py::test_webB_is_forwarded \u001b[31mFAILED\u001b[0m\ntest_multiple-networks.py::test_unknown_virtual_host \u001b[31mFAILED\u001b[0m\ntest_multiple-networks.py::test_forwards_to_web1 \u001b[31mFAILED\u001b[0m\ntest_multiple-networks.py::test_forwards_to_web2 \u001b[31mFAILED\u001b[0m\ntest_nominal.py::test_unknown_virtual_host \u001b[31mFAILED\u001b[0m\ntest_nominal.py::test_forwards_to_web1 \u001b[31mFAILED\u001b[0m\ntest_nominal.py::test_forwards_to_web2 \u001b[31mFAILED\u001b[0m\ntest_nominal.py::test_ipv6_is_disabled_by_default \u001b[32mPASSED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[f00.nginx-proxy.test-81] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[bar.nginx-proxy.test-81] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[test.nginx-proxy.f00-82] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[test.nginx-proxy.bar-82] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[web3.123.nginx-proxy.regexp-83] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[web3.ABC.nginx-proxy.regexp-83] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[web3.123.ABC.nginx-proxy.regexp-83] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[web3.123-ABC.nginx-proxy.regexp-83] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond-83] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[web4.123.nginx-proxy.regexp-84] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[web4.ABC.nginx-proxy.regexp-84] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[web4.123.ABC.nginx-proxy.regexp-84] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[web4.123-ABC.nginx-proxy.regexp-84] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_wildcard_prefix[web4.whatever.nginx-proxy.regexp-84] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_non_matching_host_is_503[unexpected.nginx-proxy.tld] \u001b[31mFAILED\u001b[0m\ntest_wildcard_host.py::test_non_matching_host_is_503[web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond] \u001b[31mFAILED\u001b[0m\nstress_tests/test_deleted_cert/test_restart_while_missing_cert.py::test_unknown_virtual_host_is_503 \u001b[33mxfail\u001b[0m\nstress_tests/test_deleted_cert/test_restart_while_missing_cert.py::test_http_web_is_301 \u001b[33mxfail\u001b[0m\nstress_tests/test_deleted_cert/test_restart_while_missing_cert.py::test_https_web_is_200 \u001b[33mxfail\u001b[0m\nstress_tests/test_deleted_cert/test_restart_while_missing_cert.py::test_delete_cert_and_restart_reverseproxy \u001b[33mxfail\u001b[0m\nstress_tests/test_deleted_cert/test_restart_while_missing_cert.py::test_unknown_virtual_host_is_still_503 \u001b[33mxfail\u001b[0m\nstress_tests/test_deleted_cert/test_restart_while_missing_cert.py::test_http_web_is_now_200 \u001b[33mxfail\u001b[0m\nstress_tests/test_deleted_cert/test_restart_while_missing_cert.py::test_https_web_is_now_broken_since_there_is_no_cert \u001b[33mxfail\u001b[0m\nstress_tests/test_unreachable_network/test_unreachable_net.py::test_default_nginx_welcome_page_should_not_be_served \u001b[33mxfail\u001b[0m\nstress_tests/test_unreachable_network/test_unreachable_net.py::test_unknown_virtual_host_is_503 \u001b[33mxfail\u001b[0m\nstress_tests/test_unreachable_network/test_unreachable_net.py::test_http_web_a_is_forwarded \u001b[33mxfail\u001b[0m\nstress_tests/test_unreachable_network/test_unreachable_net.py::test_http_web_b_gets_an_error \u001b[33mxfail\u001b[0m\nstress_tests/test_unreachable_network/test_unreachable_net.py::test_reverseproxy_survive_restart \u001b[33mxfail\u001b[0m\ntest_custom/test_defaults-location.py::test_custom_default_conf_does_not_apply_to_unknown_vhost \u001b[31mFAILED\u001b[0m\ntest_custom/test_defaults-location.py::test_custom_default_conf_applies_to_web1 \u001b[31mFAILED\u001b[0m\ntest_custom/test_defaults-location.py::test_custom_default_conf_applies_to_web2 \u001b[31mFAILED\u001b[0m\ntest_custom/test_defaults-location.py::test_custom_default_conf_is_overriden_for_web3 \u001b[31mFAILED\u001b[0m\ntest_custom/test_defaults.py::test_custom_conf_does_not_apply_to_unknown_vhost \u001b[31mFAILED\u001b[0m\ntest_custom/test_defaults.py::test_custom_conf_applies_to_web1 \u001b[31mFAILED\u001b[0m\ntest_custom/test_defaults.py::test_custom_conf_applies_to_web2 \u001b[31mFAILED\u001b[0m\ntest_custom/test_location-per-vhost.py::test_custom_conf_does_not_apply_to_unknown_vhost \u001b[31mFAILED\u001b[0m\ntest_custom/test_location-per-vhost.py::test_custom_conf_applies_to_web1 \u001b[31mFAILED\u001b[0m\ntest_custom/test_location-per-vhost.py::test_custom_conf_does_not_apply_to_web2 \u001b[31mFAILED\u001b[0m\ntest_custom/test_location-per-vhost.py::test_custom_block_is_present_in_nginx_generated_conf \u001b[31mFAILED\u001b[0m\ntest_custom/test_per-vhost.py::test_custom_conf_does_not_apply_to_unknown_vhost \u001b[31mFAILED\u001b[0m\ntest_custom/test_per-vhost.py::test_custom_conf_applies_to_web1 \u001b[31mFAILED\u001b[0m\ntest_custom/test_per-vhost.py::test_custom_conf_does_not_apply_to_web2 \u001b[31mFAILED\u001b[0m\ntest_custom/test_proxy-wide.py::test_custom_conf_does_not_apply_to_unknown_vhost \u001b[31mFAILED\u001b[0m\ntest_custom/test_proxy-wide.py::test_custom_conf_applies_to_web1 \u001b[31mFAILED\u001b[0m\ntest_custom/test_proxy-wide.py::test_custom_conf_applies_to_web2 \u001b[31mFAILED\u001b[0m\ntest_dockergen/test_dockergen_v2.py::test_unknown_virtual_host_is_503 \u001b[31mFAILED\u001b[0m\ntest_dockergen/test_dockergen_v2.py::test_forwards_to_whoami \u001b[31mFAILED\u001b[0m\ntest_dockergen/test_dockergen_v3.py::test_unknown_virtual_host_is_503 \u001b[31mFAILED\u001b[0m\ntest_dockergen/test_dockergen_v3.py::test_forwards_to_whoami \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_arbitrary_headers_are_passed_on \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_X_Forwarded_For_is_generated \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_X_Forwarded_For_is_passed_on \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_X_Forwarded_Proto_is_generated \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_X_Forwarded_Proto_is_passed_on \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_X_Forwarded_Port_is_generated \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_X_Forwarded_Port_is_passed_on \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_X_Forwarded_Ssl_is_generated \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_X_Forwarded_Ssl_is_overwritten \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_X_Real_IP_is_generated \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_Host_is_passed_on \u001b[31mFAILED\u001b[0m\ntest_headers/test_http.py::test_httpoxy_safe \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_arbitrary_headers_are_passed_on \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_X_Forwarded_For_is_generated \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_X_Forwarded_For_is_passed_on \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_X_Forwarded_Proto_is_generated \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_X_Forwarded_Proto_is_passed_on \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_X_Forwarded_Port_is_generated \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_X_Forwarded_Port_is_passed_on \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_X_Forwarded_Ssl_is_generated \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_X_Forwarded_Ssl_is_overwritten \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_X_Real_IP_is_generated \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_Host_is_passed_on \u001b[31mFAILED\u001b[0m\ntest_headers/test_https.py::test_httpoxy_safe \u001b[31mFAILED\u001b[0m\ntest_multiple-ports/test_VIRTUAL_PORT.py::test_answer_is_served_from_chosen_port \u001b[31mFAILED\u001b[0m\ntest_multiple-ports/test_default-80.py::test_answer_is_served_from_port_80_by_default \u001b[31mFAILED\u001b[0m\ntest_multiple-ports/test_single-port-not-80.py::test_answer_is_served_from_exposed_port_even_if_not_80 \u001b[31mFAILED\u001b[0m\ntest_ssl/test_dhparam.py::test_dhparam_is_not_generated_if_present \u001b[31mFAILED\u001b[0m\ntest_ssl/test_dhparam.py::test_web5_https_works \u001b[31mFAILED\u001b[0m\ntest_ssl/test_dhparam.py::test_web5_dhparam_is_used \u001b[31mFAILED\u001b[0m\ntest_ssl/test_dhparam_generation.py::test_dhparam_is_generated_if_missing \u001b[31mFAILED\u001b[0m\ntest_ssl/test_hsts.py::test_web1_HSTS_default \u001b[31mFAILED\u001b[0m\ntest_ssl/test_hsts.py::test_web1_HSTS_error \u001b[31mFAILED\u001b[0m\ntest_ssl/test_hsts.py::test_web2_HSTS_off \u001b[31mFAILED\u001b[0m\ntest_ssl/test_hsts.py::test_web3_HSTS_custom \u001b[31mFAILED\u001b[0m\ntest_ssl/test_hsts.py::test_web4_HSTS_off_noredirect \u001b[31mFAILED\u001b[0m\ntest_ssl/test_nohttp.py::test_web2_http_is_not_forwarded \u001b[31mFAILED\u001b[0m\ntest_ssl/test_nohttp.py::test_web2_https_is_forwarded \u001b[31mFAILED\u001b[0m\ntest_ssl/test_nohttp.py::test_web2_HSTS_policy_is_active \u001b[31mFAILED\u001b[0m\ntest_ssl/test_nohttps.py::test_http_is_forwarded \u001b[31mFAILED\u001b[0m\ntest_ssl/test_nohttps.py::test_https_is_disabled \u001b[32mPASSED\u001b[0m\ntest_ssl/test_noredirect.py::test_web3_http_is_forwarded \u001b[31mFAILED\u001b[0m\ntest_ssl/test_noredirect.py::test_web3_https_is_forwarded \u001b[31mFAILED\u001b[0m\ntest_ssl/test_noredirect.py::test_web2_HSTS_policy_is_inactive \u001b[31mFAILED\u001b[0m\ntest_ssl/test_wildcard.py::test_web1_http_redirects_to_https[foo] \u001b[31mFAILED\u001b[0m\ntest_ssl/test_wildcard.py::test_web1_http_redirects_to_https[bar] \u001b[31mFAILED\u001b[0m\ntest_ssl/test_wildcard.py::test_web1_https_is_forwarded[foo] \u001b[31mFAILED\u001b[0m\ntest_ssl/test_wildcard.py::test_web1_https_is_forwarded[bar] \u001b[31mFAILED\u001b[0m\ntest_ssl/test_wildcard.py::test_web1_HSTS_policy_is_active[foo] \u001b[31mFAILED\u001b[0m\ntest_ssl/test_wildcard.py::test_web1_HSTS_policy_is_active[bar] \u001b[31mFAILED\u001b[0m\ntest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py::test_http_redirects_to_https[1-True] \u001b[31mFAILED\u001b[0m\ntest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py::test_http_redirects_to_https[2-True] \u001b[31mFAILED\u001b[0m\ntest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py::test_http_redirects_to_https[3-False] \u001b[31mFAILED\u001b[0m\ntest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py::test_https_get_served[1] \u001b[31mFAILED\u001b[0m\ntest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py::test_https_get_served[2] \u001b[31mFAILED\u001b[0m\ntest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py::test_web3_https_is_500_and_SSL_validation_fails \u001b[31mFAILED\u001b[0m\n\n=================================== FAILURES ===================================\n\u001b[1m\u001b[31m__________________________ test_unknown_virtual_host ___________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96f34f10>\n\n\u001b[1m    def test_unknown_virtual_host(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_DOCKER_HOST_unix_socket.py\u001b[0m:4: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96f66390>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96f66b50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96f4b610>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:21 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:21 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:21 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_DOCKER_HOST_unix_socket.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m____________________________ test_forwards_to_web1 _____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96f49710>\n\n\u001b[1m    def test_forwards_to_web1(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_DOCKER_HOST_unix_socket.py\u001b[0m:8: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96f49050>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96e2f5d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96e2f650>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:21 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:21 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:21 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.tld')\nDEBUG:DNS:'web1.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m____________________________ test_forwards_to_web2 _____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96e72b50>\n\n\u001b[1m    def test_forwards_to_web2(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_DOCKER_HOST_unix_socket.py\u001b[0m:13: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96e72d90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96e72d10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96e2fb10>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:21 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:21 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:21 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.tld')\nDEBUG:DNS:'web2.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_DOCKER_HOST_unix_socket.yml down\n\u001b[1m\u001b[31m__________________________ test_unknown_virtual_host ___________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96e84290>\n\n\u001b[1m    def test_unknown_virtual_host(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_composev2.py\u001b[0m:4: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96e2f9d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96e14990>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96e14790>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:27 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:27 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:27 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_composev2.yml up -d\nINFO:root:Connecting to docker network: test_default\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m___________________________ test_forwards_to_whoami ____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96e14c10>\n\n\u001b[1m    def test_forwards_to_whoami(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_composev2.py\u001b[0m:8: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c4c050>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c4c790>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96c4c5d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:27 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:27 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:27 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.local')\nDEBUG:DNS:'web.nginx-proxy.local' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:Disconnecting from network test_default\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_composev2.yml down\n\u001b[1m\u001b[31m___________________________ test_fallback_on_default ___________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c4c850>\n\n\u001b[1m    def test_fallback_on_default(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://unknown.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_default-host.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d23490>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96da6590>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='unknown.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96da6e50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:33 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:33 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:33 Watching docker events\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:33 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:33 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:33 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_default-host.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('unknown.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('unknown.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'unknown.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('unknown.nginx-proxy.tld')\nDEBUG:DNS:'unknown.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_default-host.yml down\n\u001b[1m\u001b[31m_____________________ test_nginx_proxy_behavior_when_alone _____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96dc4d50>\n\n\u001b[1m    def test_nginx_proxy_behavior_when_alone(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_events.py\u001b[0m:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cdfa10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cdfc50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96cdf290>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:38 Generated '/app/htpasswd_generator.sh' from 2 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:38 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_events.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m________________________ test_new_container_is_detected ________________________\u001b[0m\n\nweb1 = <Container: b396381d90>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d23190>\n\n\u001b[1m    def test_new_container_is_detected(web1, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_events.py\u001b[0m:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cc4a50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96be5190>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96be5290>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:38 Generated '/app/htpasswd_generator.sh' from 2 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:38 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy')\nDEBUG:DNS:'web1.nginx-proxy' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_events.yml down\n\u001b[1m\u001b[31m________________________ test_unknown_virtual_host_ipv4 ________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96dc4c90>\n\n\u001b[1m    def test_unknown_virtual_host_ipv4(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_ipv6.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96f4bc50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96f666d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96f665d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:46 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ipv6.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m__________________________ test_forwards_to_web1_ipv4 __________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96da6e90>\n\n\u001b[1m    def test_forwards_to_web1_ipv4(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_ipv6.py\u001b[0m:10: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96da64d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c4c750>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96c4c150>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:46 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.tld')\nDEBUG:DNS:'web1.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m__________________________ test_forwards_to_web2_ipv4 __________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96f66bd0>\n\n\u001b[1m    def test_forwards_to_web2_ipv4(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_ipv6.py\u001b[0m:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cf32d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cf3b90>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96cf37d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:46 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.tld')\nDEBUG:DNS:'web2.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m________________________ test_unknown_virtual_host_ipv6 ________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96dc8b50>\n\n\u001b[1m    def test_unknown_virtual_host_ipv6(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/port\", ipv6=True)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ipv6.py\u001b[0m:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96dc8190>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c4c310>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96c46c10>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:46 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m__________________________ test_forwards_to_web1_ipv6 __________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cf3210>\n\n\u001b[1m    def test_forwards_to_web1_ipv6(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy.tld/port\", ipv6=True)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ipv6.py\u001b[0m:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96e14850>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96e14890>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96e14b10>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:46 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.tld')\nDEBUG:DNS:'web1.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m__________________________ test_forwards_to_web2_ipv6 __________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96ccf410>\n\n\u001b[1m    def test_forwards_to_web2_ipv6(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.tld/port\", ipv6=True)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ipv6.py\u001b[0m:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96ccfc90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96ccfb50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96ccfdd0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:46 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:46 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.tld')\nDEBUG:DNS:'web2.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ipv6.yml down\n\u001b[1m\u001b[31m_______________________ test_unknown_virtual_host_is_503 _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96df9510>\n\n\u001b[1m    def test_unknown_virtual_host_is_503(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://unknown.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_multiple-hosts.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d640d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d646d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='unknown.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d64790>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:53 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:53 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_multiple-hosts.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('unknown.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('unknown.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'unknown.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('unknown.nginx-proxy.tld')\nDEBUG:DNS:'unknown.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m____________________________ test_webA_is_forwarded ____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d3b950>\n\n\u001b[1m    def test_webA_is_forwarded(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://webA.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_multiple-hosts.py\u001b[0m:9: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d3b3d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96eb0d90>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='weba.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96eb0e90>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:53 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:53 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('weba.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('weba.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'weba.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('weba.nginx-proxy.tld')\nDEBUG:DNS:'weba.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m____________________________ test_webB_is_forwarded ____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96f499d0>\n\n\u001b[1m    def test_webB_is_forwarded(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://webB.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_multiple-hosts.py\u001b[0m:14: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96f49710>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96eb0290>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='webb.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96eb0ad0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:04:53 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:53 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('webb.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('webb.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'webb.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('webb.nginx-proxy.tld')\nDEBUG:DNS:'webb.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_multiple-hosts.yml down\n\u001b[1m\u001b[31m__________________________ test_unknown_virtual_host ___________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d7f5d0>\n\n\u001b[1m    def test_unknown_virtual_host(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_multiple-networks.py\u001b[0m:4: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cbed10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cbe9d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96cbea50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:59 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_multiple-networks.yml up -d\nINFO:root:Connecting to docker network: test_net2\nINFO:root:Connecting to docker network: test_net1\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m____________________________ test_forwards_to_web1 _____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96e84550>\n\n\u001b[1m    def test_forwards_to_web1(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_multiple-networks.py\u001b[0m:8: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d76c10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d76410>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d76110>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:59 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.local')\nDEBUG:DNS:'web1.nginx-proxy.local' does not match\n\u001b[1m\u001b[31m____________________________ test_forwards_to_web2 _____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c46410>\n\n\u001b[1m    def test_forwards_to_web2(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_multiple-networks.py\u001b[0m:13: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c460d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c46710>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d11850>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:04:59 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.local')\nDEBUG:DNS:'web2.nginx-proxy.local' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:Disconnecting from network test_net2\nINFO:root:Disconnecting from network test_net1\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_multiple-networks.yml down\n\u001b[1m\u001b[31m__________________________ test_unknown_virtual_host ___________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cc4910>\n\n\u001b[1m    def test_unknown_virtual_host(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_nominal.py\u001b[0m:6: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96dc4750>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96dc4c10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96dc4fd0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:06 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:06 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:06 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_nominal.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m____________________________ test_forwards_to_web1 _____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cfccd0>\n\n\u001b[1m    def test_forwards_to_web1(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_nominal.py\u001b[0m:11: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cfc9d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cfc610>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d01310>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:06 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:06 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:06 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.tld')\nDEBUG:DNS:'web1.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m____________________________ test_forwards_to_web2 _____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d70dd0>\n\n\u001b[1m    def test_forwards_to_web2(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_nominal.py\u001b[0m:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d709d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d70210>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d70650>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:06 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:06 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:06 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.tld')\nDEBUG:DNS:'web2.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m________________ test_wildcard_prefix[f00.nginx-proxy.test-81] _________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a970e0ed0>\nhost = 'f00.nginx-proxy.test', expected_port = 81\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cd6c10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cd61d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='f00.nginx-proxy.test', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96bc4290>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_wildcard_host.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('f00.nginx-proxy.test', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('f00.nginx-proxy.test')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'f00.nginx-proxy.test'\nDEBUG:DNS:docker_container_dns_resolver('f00.nginx-proxy.test')\nDEBUG:DNS:'f00.nginx-proxy.test' does not match\n\u001b[1m\u001b[31m________________ test_wildcard_prefix[bar.nginx-proxy.test-81] _________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cb79d0>\nhost = 'bar.nginx-proxy.test', expected_port = 81\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cb7310>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bbf750>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='bar.nginx-proxy.test', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96bbf990>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('bar.nginx-proxy.test', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('bar.nginx-proxy.test')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'bar.nginx-proxy.test'\nDEBUG:DNS:docker_container_dns_resolver('bar.nginx-proxy.test')\nDEBUG:DNS:'bar.nginx-proxy.test' does not match\n\u001b[1m\u001b[31m________________ test_wildcard_prefix[test.nginx-proxy.f00-82] _________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96f27890>\nhost = 'test.nginx-proxy.f00', expected_port = 82\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96f4ba50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96f4bc50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='test.nginx-proxy.f00', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d97b50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('test.nginx-proxy.f00', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('test.nginx-proxy.f00')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'test.nginx-proxy.f00'\nDEBUG:DNS:docker_container_dns_resolver('test.nginx-proxy.f00')\nDEBUG:DNS:'test.nginx-proxy.f00' does not match\n\u001b[1m\u001b[31m________________ test_wildcard_prefix[test.nginx-proxy.bar-82] _________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96be53d0>\nhost = 'test.nginx-proxy.bar', expected_port = 82\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96be5790>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96be5150>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='test.nginx-proxy.bar', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96bbf090>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('test.nginx-proxy.bar', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('test.nginx-proxy.bar')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'test.nginx-proxy.bar'\nDEBUG:DNS:docker_container_dns_resolver('test.nginx-proxy.bar')\nDEBUG:DNS:'test.nginx-proxy.bar' does not match\n\u001b[1m\u001b[31m_____________ test_wildcard_prefix[web3.123.nginx-proxy.regexp-83] _____________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c4c9d0>\nhost = 'web3.123.nginx-proxy.regexp', expected_port = 83\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c4c410>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c4c2d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web3.123.nginx-proxy.regexp', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96cbe450>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web3.123.nginx-proxy.regexp', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web3.123.nginx-proxy.regexp')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web3.123.nginx-proxy.regexp'\nDEBUG:DNS:docker_container_dns_resolver('web3.123.nginx-proxy.regexp')\nDEBUG:DNS:'web3.123.nginx-proxy.regexp' does not match\n\u001b[1m\u001b[31m_____________ test_wildcard_prefix[web3.ABC.nginx-proxy.regexp-83] _____________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d7f1d0>\nhost = 'web3.ABC.nginx-proxy.regexp', expected_port = 83\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d7fb90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c06810>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web3.abc.nginx-proxy.regexp', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96c06190>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web3.abc.nginx-proxy.regexp', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web3.abc.nginx-proxy.regexp')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web3.abc.nginx-proxy.regexp'\nDEBUG:DNS:docker_container_dns_resolver('web3.abc.nginx-proxy.regexp')\nDEBUG:DNS:'web3.abc.nginx-proxy.regexp' does not match\n\u001b[1m\u001b[31m___________ test_wildcard_prefix[web3.123.ABC.nginx-proxy.regexp-83] ___________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cbe0d0>\nhost = 'web3.123.ABC.nginx-proxy.regexp', expected_port = 83\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cbe410>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d64290>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web3.123.abc.nginx-proxy.regexp', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d64850>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web3.123.abc.nginx-proxy.regexp', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web3.123.abc.nginx-proxy.regexp')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web3.123.abc.nginx-proxy.regexp'\nDEBUG:DNS:docker_container_dns_resolver('web3.123.abc.nginx-proxy.regexp')\nDEBUG:DNS:'web3.123.abc.nginx-proxy.regexp' does not match\n\u001b[1m\u001b[31m___________ test_wildcard_prefix[web3.123-ABC.nginx-proxy.regexp-83] ___________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d3b290>\nhost = 'web3.123-ABC.nginx-proxy.regexp', expected_port = 83\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d3b3d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c06b10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web3.123-abc.nginx-proxy.regexp', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96c060d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web3.123-abc.nginx-proxy.regexp', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web3.123-abc.nginx-proxy.regexp')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web3.123-abc.nginx-proxy.regexp'\nDEBUG:DNS:docker_container_dns_resolver('web3.123-abc.nginx-proxy.regexp')\nDEBUG:DNS:'web3.123-abc.nginx-proxy.regexp' does not match\n\u001b[1m\u001b[31m_ test_wildcard_prefix[web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond-83] _\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96ed3d10>\nhost = 'web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond'\nexpected_port = 83\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96ed3b90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96ed3f10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96ed30d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond'\nDEBUG:DNS:docker_container_dns_resolver('web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond')\nDEBUG:DNS:'web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond' does not match\n\u001b[1m\u001b[31m_____________ test_wildcard_prefix[web4.123.nginx-proxy.regexp-84] _____________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bb1110>\nhost = 'web4.123.nginx-proxy.regexp', expected_port = 84\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bb18d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bb1a90>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web4.123.nginx-proxy.regexp', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96bd4c90>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web4.123.nginx-proxy.regexp', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web4.123.nginx-proxy.regexp')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web4.123.nginx-proxy.regexp'\nDEBUG:DNS:docker_container_dns_resolver('web4.123.nginx-proxy.regexp')\nDEBUG:DNS:'web4.123.nginx-proxy.regexp' does not match\n\u001b[1m\u001b[31m_____________ test_wildcard_prefix[web4.ABC.nginx-proxy.regexp-84] _____________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d64990>\nhost = 'web4.ABC.nginx-proxy.regexp', expected_port = 84\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96dbdf90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96dbd910>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web4.abc.nginx-proxy.regexp', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96dbda90>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web4.abc.nginx-proxy.regexp', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web4.abc.nginx-proxy.regexp')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web4.abc.nginx-proxy.regexp'\nDEBUG:DNS:docker_container_dns_resolver('web4.abc.nginx-proxy.regexp')\nDEBUG:DNS:'web4.abc.nginx-proxy.regexp' does not match\n\u001b[1m\u001b[31m___________ test_wildcard_prefix[web4.123.ABC.nginx-proxy.regexp-84] ___________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cdfb50>\nhost = 'web4.123.ABC.nginx-proxy.regexp', expected_port = 84\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96f09a10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96e72e50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web4.123.abc.nginx-proxy.regexp', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96e72890>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web4.123.abc.nginx-proxy.regexp', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web4.123.abc.nginx-proxy.regexp')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web4.123.abc.nginx-proxy.regexp'\nDEBUG:DNS:docker_container_dns_resolver('web4.123.abc.nginx-proxy.regexp')\nDEBUG:DNS:'web4.123.abc.nginx-proxy.regexp' does not match\n\u001b[1m\u001b[31m___________ test_wildcard_prefix[web4.123-ABC.nginx-proxy.regexp-84] ___________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96f66a10>\nhost = 'web4.123-ABC.nginx-proxy.regexp', expected_port = 84\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96f66810>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d76c90>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web4.123-abc.nginx-proxy.regexp', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d76d50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web4.123-abc.nginx-proxy.regexp', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web4.123-abc.nginx-proxy.regexp')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web4.123-abc.nginx-proxy.regexp'\nDEBUG:DNS:docker_container_dns_resolver('web4.123-abc.nginx-proxy.regexp')\nDEBUG:DNS:'web4.123-abc.nginx-proxy.regexp' does not match\n\u001b[1m\u001b[31m__________ test_wildcard_prefix[web4.whatever.nginx-proxy.regexp-84] ___________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c564d0>\nhost = 'web4.whatever.nginx-proxy.regexp', expected_port = 84\n\n\u001b[1m    @pytest.mark.parametrize(\"host,expected_port\", [\u001b[0m\n\u001b[1m        (\"f00.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"bar.nginx-proxy.test\", 81),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.f00\", 82),\u001b[0m\n\u001b[1m        (\"test.nginx-proxy.bar\", 82),\u001b[0m\n\u001b[1m        (\"web3.123.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123.ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.123-ABC.nginx-proxy.regexp\", 83),\u001b[0m\n\u001b[1m        (\"web3.whatever.nginx-proxy.regexp-to-infinity-and-beyond\", 83),\u001b[0m\n\u001b[1m        (\"web4.123.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123.ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.123-ABC.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m        (\"web4.whatever.nginx-proxy.regexp\", 84),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_wildcard_prefix(docker_compose, nginxproxy, host, expected_port):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c56d10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c56bd0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web4.whatever.nginx-proxy.regexp', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96e14bd0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web4.whatever.nginx-proxy.regexp', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web4.whatever.nginx-proxy.regexp')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web4.whatever.nginx-proxy.regexp'\nDEBUG:DNS:docker_container_dns_resolver('web4.whatever.nginx-proxy.regexp')\nDEBUG:DNS:'web4.whatever.nginx-proxy.regexp' does not match\n\u001b[1m\u001b[31m__________ test_non_matching_host_is_503[unexpected.nginx-proxy.tld] ___________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96f4bf10>\nhost = 'unexpected.nginx-proxy.tld'\n\n\u001b[1m    @pytest.mark.parametrize(\"host\", [\u001b[0m\n\u001b[1m        \"unexpected.nginx-proxy.tld\",\u001b[0m\n\u001b[1m        \"web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond\"\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_non_matching_host_is_503(docker_compose, nginxproxy, host):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d76910>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d76150>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='unexpected.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d9afd0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('unexpected.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('unexpected.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'unexpected.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('unexpected.nginx-proxy.tld')\nDEBUG:DNS:'unexpected.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_ test_non_matching_host_is_503[web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond] _\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d11610>\nhost = 'web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond'\n\n\u001b[1m    @pytest.mark.parametrize(\"host\", [\u001b[0m\n\u001b[1m        \"unexpected.nginx-proxy.tld\",\u001b[0m\n\u001b[1m        \"web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond\"\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_non_matching_host_is_503(docker_compose, nginxproxy, host):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s/port\" % host)\u001b[0m\n\n\u001b[1m\u001b[31mtest_wildcard_host.py\u001b[0m:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96e14b90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96e14610>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96bc9690>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:12 Generated '/app/htpasswd_generator.sh' from 6 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:12 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond'\nDEBUG:DNS:docker_container_dns_resolver('web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond')\nDEBUG:DNS:'web4.whatever.nginx-proxy.regexp-to-infinity-and-beyond' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_wildcard_host.yml down\n\u001b[1m\u001b[31m___________ test_custom_default_conf_does_not_apply_to_unknown_vhost ___________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bc9290>\n\n\u001b[1m    def test_custom_default_conf_does_not_apply_to_unknown_vhost(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_defaults-location.py\u001b[0m:4: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bc9110>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96baf150>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96baf310>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:40 Generated '/app/htpasswd_generator.sh' from 5 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:40 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:40 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_custom/test_defaults-location.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m___________________ test_custom_default_conf_applies_to_web1 ___________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bdb290>\n\n\u001b[1m    def test_custom_default_conf_applies_to_web1(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_defaults-location.py\u001b[0m:9: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bdbe10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96df5750>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96df5ad0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:40 Generated '/app/htpasswd_generator.sh' from 5 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:40 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:40 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.local')\nDEBUG:DNS:'web1.nginx-proxy.local' does not match\n\u001b[1m\u001b[31m___________________ test_custom_default_conf_applies_to_web2 ___________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cd65d0>\n\n\u001b[1m    def test_custom_default_conf_applies_to_web2(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_defaults-location.py\u001b[0m:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cd6bd0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cd6090>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96cd6450>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:40 Generated '/app/htpasswd_generator.sh' from 5 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:40 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:40 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.local')\nDEBUG:DNS:'web2.nginx-proxy.local' does not match\n\u001b[1m\u001b[31m________________ test_custom_default_conf_is_overriden_for_web3 ________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96e2fa90>\n\n\u001b[1m    def test_custom_default_conf_is_overriden_for_web3(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web3.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_defaults-location.py\u001b[0m:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d3b290>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d3b710>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web3.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96ed37d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:40 Generated '/app/htpasswd_generator.sh' from 5 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:40 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:40 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web3.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web3.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web3.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web3.nginx-proxy.local')\nDEBUG:DNS:'web3.nginx-proxy.local' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_custom/test_defaults-location.yml down\n\u001b[1m\u001b[31m_______________ test_custom_conf_does_not_apply_to_unknown_vhost _______________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96b463d0>\n\n\u001b[1m    def test_custom_conf_does_not_apply_to_unknown_vhost(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_defaults.py\u001b[0m:4: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96b46250>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cfc710>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96cfc550>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:47 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:47 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:47 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_custom/test_defaults.yml up -d\nINFO:root:Connecting to docker network: testcustom_default\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m_______________________ test_custom_conf_applies_to_web1 _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d71350>\n\n\u001b[1m    def test_custom_conf_applies_to_web1(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_defaults.py\u001b[0m:9: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cf3090>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cf3150>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96cf3210>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:47 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:47 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:47 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.local')\nDEBUG:DNS:'web1.nginx-proxy.local' does not match\n\u001b[1m\u001b[31m_______________________ test_custom_conf_applies_to_web2 _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96df9510>\n\n\u001b[1m    def test_custom_conf_applies_to_web2(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_defaults.py\u001b[0m:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96da6810>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96da6210>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96be98d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:47 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:47 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:47 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.local')\nDEBUG:DNS:'web2.nginx-proxy.local' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:Disconnecting from network testcustom_default\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_custom/test_defaults.yml down\n\u001b[1m\u001b[31m_______________ test_custom_conf_does_not_apply_to_unknown_vhost _______________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d90ed0>\n\n\u001b[1m    def test_custom_conf_does_not_apply_to_unknown_vhost(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_location-per-vhost.py\u001b[0m:4: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d90810>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bafe90>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96bafb90>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:53 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:53 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:53 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:53 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:54 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:54 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:54 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_custom/test_location-per-vhost.yml up -d\nINFO:root:Connecting to docker network: testcustom_default\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m_______________________ test_custom_conf_applies_to_web1 _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c44650>\n\n\u001b[1m    def test_custom_conf_applies_to_web1(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_location-per-vhost.py\u001b[0m:9: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c445d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c44e10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d01290>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:53 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:53 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:53 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:53 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:54 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:54 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:54 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.local')\nDEBUG:DNS:'web1.nginx-proxy.local' does not match\n\u001b[1m\u001b[31m___________________ test_custom_conf_does_not_apply_to_web2 ____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bc4890>\n\n\u001b[1m    def test_custom_conf_does_not_apply_to_web2(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_location-per-vhost.py\u001b[0m:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bc4f10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96b9f510>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96b9fed0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:53 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:53 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:05:53 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:53 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:54 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:54 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:05:54 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.local')\nDEBUG:DNS:'web2.nginx-proxy.local' does not match\n\u001b[1m\u001b[31m_____________ test_custom_block_is_present_in_nginx_generated_conf _____________\u001b[0m\nNo running jwilder/nginx-proxy:test container\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:Disconnecting from network testcustom_default\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_custom/test_location-per-vhost.yml down\n\u001b[1m\u001b[31m_______________ test_custom_conf_does_not_apply_to_unknown_vhost _______________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bbab50>\n\n\u001b[1m    def test_custom_conf_does_not_apply_to_unknown_vhost(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_per-vhost.py\u001b[0m:4: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bbad50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bd4510>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96bd4150>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:00 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:00 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_custom/test_per-vhost.yml up -d\nINFO:root:Connecting to docker network: testcustom_default\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m_______________________ test_custom_conf_applies_to_web1 _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96f66ad0>\n\n\u001b[1m    def test_custom_conf_applies_to_web1(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_per-vhost.py\u001b[0m:9: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96e840d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96e84750>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96bd40d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:00 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:00 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.local')\nDEBUG:DNS:'web1.nginx-proxy.local' does not match\n\u001b[1m\u001b[31m___________________ test_custom_conf_does_not_apply_to_web2 ____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c560d0>\n\n\u001b[1m    def test_custom_conf_does_not_apply_to_web2(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_per-vhost.py\u001b[0m:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c56a10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96b318d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96be54d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:00 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:00 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.local')\nDEBUG:DNS:'web2.nginx-proxy.local' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:Disconnecting from network testcustom_default\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_custom/test_per-vhost.yml down\n\u001b[1m\u001b[31m_______________ test_custom_conf_does_not_apply_to_unknown_vhost _______________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bd41d0>\n\n\u001b[1m    def test_custom_conf_does_not_apply_to_unknown_vhost(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://nginx-proxy/\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_proxy-wide.py\u001b[0m:4: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d90410>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96dbdb50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='nginx-proxy', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96dbd8d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:07 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:07 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:07 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_custom/test_proxy-wide.yml up -d\nINFO:root:Connecting to docker network: testcustom_default\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('nginx-proxy', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('nginx-proxy')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'nginx-proxy'\nDEBUG:DNS:docker_container_dns_resolver('nginx-proxy')\nDEBUG:DNS:'nginx-proxy' does not match\n\u001b[1m\u001b[31m_______________________ test_custom_conf_applies_to_web1 _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c4b8d0>\n\n\u001b[1m    def test_custom_conf_applies_to_web1(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web1.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_proxy-wide.py\u001b[0m:9: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a969831d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96983710>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web1.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96983d90>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:07 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:07 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:07 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.local')\nDEBUG:DNS:'web1.nginx-proxy.local' does not match\n\u001b[1m\u001b[31m_______________________ test_custom_conf_applies_to_web2 _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96e148d0>\n\n\u001b[1m    def test_custom_conf_applies_to_web2(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.local/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_custom/test_proxy-wide.py\u001b[0m:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96f4bb10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96df0750>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.local', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96df0c50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:07 Generated '/app/htpasswd_generator.sh' from 4 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:07 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:07 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.local', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.local')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.local'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.local')\nDEBUG:DNS:'web2.nginx-proxy.local' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:Disconnecting from network testcustom_default\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_custom/test_proxy-wide.yml down\n\u001b[1m\u001b[31m_______________________ test_unknown_virtual_host_is_503 _______________________\u001b[0m\n\nnginx_tmpl = None\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96e2f090>\n\n\u001b[1m    def test_unknown_virtual_host_is_503(nginx_tmpl, docker_compose, nginxproxy):\u001b[0m\n\u001b[1m        r = nginxproxy.get(\"http://unknown.nginx.container.docker/\")\u001b[0m\n\u001b[1m>       assert r.status_code == 503\u001b[0m\n\u001b[1m\u001b[31mE       assert 200 == 503\u001b[0m\n\u001b[1m\u001b[31mE        +  where 200 = <Response [200]>.status_code\u001b[0m\n\n\u001b[1m\u001b[31mtest_dockergen/test_dockergen_v2.py\u001b[0m:31: AssertionError\n---------------------------- Captured stdout setup -----------------------------\n+ cp /app/nginx.tmpl /home/travis/build/jwilder/nginx-proxy/test/test_dockergen\n+ chmod 777 /home/travis/build/jwilder/nginx-proxy/test/test_dockergen/nginx.tmpl\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:extracting nginx.tmpl from jwilder/nginx-proxy:test\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_dockergen/test_dockergen_v2.yml up -d\nINFO:root:Connecting to docker network: testdockergen_default\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('unknown.nginx.container.docker', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('unknown.nginx.container.docker')\nDEBUG:DNS:docker_container_dns_resolver('unknown.nginx.container.docker')\nDEBUG:DNS:looking for container 'nginx'\nDEBUG:DNS:container u'nginx' found (f25cec7e46)\nINFO:DNS:resolving domain name 'unknown.nginx.container.docker' as IP address 172.27.0.2 of container nginx\n\u001b[1m\u001b[31m___________________________ test_forwards_to_whoami ____________________________\u001b[0m\n\nnginx_tmpl = None\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96dc4d50>\n\n\u001b[1m    def test_forwards_to_whoami(nginx_tmpl, docker_compose, nginxproxy):\u001b[0m\n\u001b[1m        r = nginxproxy.get(\"http://whoami.nginx.container.docker/\")\u001b[0m\n\u001b[1m        assert r.status_code == 200\u001b[0m\n\u001b[1m        whoami_container = docker_compose.containers.get(\"whoami\")\u001b[0m\n\u001b[1m>       assert r.text == \"I'm %s\\n\" % whoami_container.id[:12]\u001b[0m\n\u001b[1m\u001b[31mE       assert '<!DOCTYPE ht...ody>\\n</html>\\n' == \"I'm ee525f30fe20\\n\"\u001b[0m\n\u001b[1m\u001b[31mE         + I'm ee525f30fe20\u001b[0m\n\u001b[1m\u001b[31mE         - <!DOCTYPE html>\u001b[0m\n\u001b[1m\u001b[31mE         - <html>\u001b[0m\n\u001b[1m\u001b[31mE         - <head>\u001b[0m\n\u001b[1m\u001b[31mE         - <title>Welcome to nginx!</title>\u001b[0m\n\u001b[1m\u001b[31mE         - <style>\u001b[0m\n\u001b[1m\u001b[31mE         -     body {\u001b[0m\n\u001b[1m\u001b[31mE         -         width: 35em;\u001b[0m\n\u001b[1m\u001b[31mE         -         margin: 0 auto;\u001b[0m\n\u001b[1m\u001b[31mE         Detailed information truncated (17 more lines), use \"-vv\" to show\u001b[0m\n\n\u001b[1m\u001b[31mtest_dockergen/test_dockergen_v2.py\u001b[0m:38: AssertionError\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('whoami.nginx.container.docker', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('whoami.nginx.container.docker')\nDEBUG:DNS:docker_container_dns_resolver('whoami.nginx.container.docker')\nDEBUG:DNS:looking for container 'nginx'\nDEBUG:DNS:container u'nginx' found (f25cec7e46)\nINFO:DNS:resolving domain name 'whoami.nginx.container.docker' as IP address 172.27.0.2 of container nginx\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:Disconnecting from network testdockergen_default\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_dockergen/test_dockergen_v2.yml down\nINFO:root:removing nginx.tmpl\n\u001b[1m\u001b[31m_______________________ test_unknown_virtual_host_is_503 _______________________\u001b[0m\n\nnginx_tmpl = None\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96dc4dd0>\n\n\u001b[1m    def test_unknown_virtual_host_is_503(nginx_tmpl, docker_compose, nginxproxy):\u001b[0m\n\u001b[1m        r = nginxproxy.get(\"http://unknown.nginx.container.docker/\")\u001b[0m\n\u001b[1m>       assert r.status_code == 503\u001b[0m\n\u001b[1m\u001b[31mE       assert 200 == 503\u001b[0m\n\u001b[1m\u001b[31mE        +  where 200 = <Response [200]>.status_code\u001b[0m\n\n\u001b[1m\u001b[31mtest_dockergen/test_dockergen_v3.py\u001b[0m:54: AssertionError\n---------------------------- Captured stdout setup -----------------------------\n+ cp /app/nginx.tmpl /home/travis/build/jwilder/nginx-proxy/test/test_dockergen\n+ chmod 777 /home/travis/build/jwilder/nginx-proxy/test/test_dockergen/nginx.tmpl\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:extracting nginx.tmpl from jwilder/nginx-proxy:test\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_dockergen/test_dockergen_v3.yml up -d\nINFO:root:Connecting to docker network: testdockergen_default\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('unknown.nginx.container.docker', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('unknown.nginx.container.docker')\nDEBUG:DNS:docker_container_dns_resolver('unknown.nginx.container.docker')\nDEBUG:DNS:looking for container 'nginx'\nDEBUG:DNS:container u'nginx' found (ce649ea28e)\nINFO:DNS:resolving domain name 'unknown.nginx.container.docker' as IP address 172.28.0.2 of container nginx\n\u001b[1m\u001b[31m___________________________ test_forwards_to_whoami ____________________________\u001b[0m\n\nnginx_tmpl = None\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96af5650>\n\n\u001b[1m    def test_forwards_to_whoami(nginx_tmpl, docker_compose, nginxproxy):\u001b[0m\n\u001b[1m        r = nginxproxy.get(\"http://whoami.nginx.container.docker/\")\u001b[0m\n\u001b[1m        assert r.status_code == 200\u001b[0m\n\u001b[1m        whoami_container = docker_compose.containers.get(\"whoami\")\u001b[0m\n\u001b[1m>       assert r.text == \"I'm %s\\n\" % whoami_container.id[:12]\u001b[0m\n\u001b[1m\u001b[31mE       assert '<!DOCTYPE ht...ody>\\n</html>\\n' == \"I'm bc3a35dae7e5\\n\"\u001b[0m\n\u001b[1m\u001b[31mE         + I'm bc3a35dae7e5\u001b[0m\n\u001b[1m\u001b[31mE         - <!DOCTYPE html>\u001b[0m\n\u001b[1m\u001b[31mE         - <html>\u001b[0m\n\u001b[1m\u001b[31mE         - <head>\u001b[0m\n\u001b[1m\u001b[31mE         - <title>Welcome to nginx!</title>\u001b[0m\n\u001b[1m\u001b[31mE         - <style>\u001b[0m\n\u001b[1m\u001b[31mE         -     body {\u001b[0m\n\u001b[1m\u001b[31mE         -         width: 35em;\u001b[0m\n\u001b[1m\u001b[31mE         -         margin: 0 auto;\u001b[0m\n\u001b[1m\u001b[31mE         Detailed information truncated (17 more lines), use \"-vv\" to show\u001b[0m\n\n\u001b[1m\u001b[31mtest_dockergen/test_dockergen_v3.py\u001b[0m:61: AssertionError\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('whoami.nginx.container.docker', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('whoami.nginx.container.docker')\nDEBUG:DNS:docker_container_dns_resolver('whoami.nginx.container.docker')\nDEBUG:DNS:looking for container 'nginx'\nDEBUG:DNS:container u'nginx' found (ce649ea28e)\nINFO:DNS:resolving domain name 'whoami.nginx.container.docker' as IP address 172.28.0.2 of container nginx\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:Disconnecting from network testdockergen_default\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_dockergen/test_dockergen_v3.yml down\nINFO:root:removing nginx.tmpl\n\u001b[1m\u001b[31m_____________________ test_arbitrary_headers_are_passed_on _____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d7fa10>\n\n\u001b[1m    def test_arbitrary_headers_are_passed_on(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\", headers={'Foo': 'Bar'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:4: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96af2f50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96af2bd0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96c801d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_headers/test_http.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_X_Forwarded_For_is_generated _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bd8690>\n\n\u001b[1m    def test_X_Forwarded_For_is_generated(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:12: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bd8f50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96af2810>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96e14810>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_X_Forwarded_For_is_passed_on _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cb8410>\n\n\u001b[1m    def test_X_Forwarded_For_is_passed_on(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\", headers={'X-Forwarded-For': '1.2.3.4'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cbe810>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cc4390>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96cc4ad0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_____________________ test_X_Forwarded_Proto_is_generated ______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96ba1410>\n\n\u001b[1m    def test_X_Forwarded_Proto_is_generated(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c4c450>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bbf750>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96bbf310>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_____________________ test_X_Forwarded_Proto_is_passed_on ______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96da3350>\n\n\u001b[1m    def test_X_Forwarded_Proto_is_passed_on(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\", headers={'X-Forwarded-Proto': 'f00'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96da3390>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96da3cd0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96da3650>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_X_Forwarded_Port_is_generated ______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cdfa10>\n\n\u001b[1m    def test_X_Forwarded_Port_is_generated(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96dc81d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96dc8f10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96baf710>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_X_Forwarded_Port_is_passed_on ______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d90990>\n\n\u001b[1m    def test_X_Forwarded_Port_is_passed_on(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\", headers={'X-Forwarded-Port': '1234'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d90f90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d909d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d90e50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_X_Forwarded_Ssl_is_generated _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96b49050>\n\n\u001b[1m    def test_X_Forwarded_Ssl_is_generated(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96b49550>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cd6dd0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96cd6c90>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_____________________ test_X_Forwarded_Ssl_is_overwritten ______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bc97d0>\n\n\u001b[1m    def test_X_Forwarded_Ssl_is_overwritten(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\", headers={'X-Forwarded-Ssl': 'f00'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:56: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bc9b90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bae5d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96baec50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_________________________ test_X_Real_IP_is_generated __________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bb2890>\n\n\u001b[1m    def test_X_Real_IP_is_generated(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bb2950>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96baf850>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96baf250>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m____________________________ test_Host_is_passed_on ____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d76f50>\n\n\u001b[1m    def test_Host_is_passed_on(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:69: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d76c50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d90450>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d90950>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________________ test_httpoxy_safe _______________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d70f50>\n\n\u001b[1m    def test_httpoxy_safe(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m        \"\"\"\u001b[0m\n\u001b[1m        See https://httpoxy.org/\u001b[0m\n\u001b[1m        nginx-proxy should suppress the `Proxy` header\u001b[0m\n\u001b[1m        \"\"\"\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/headers\", headers={'Proxy': 'tcp://some.hacker.com'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_http.py\u001b[0m:78: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cd6510>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96eb0650>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96eb0590>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:31 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:31 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_headers/test_http.yml down\n\u001b[1m\u001b[31m_____________________ test_arbitrary_headers_are_passed_on _____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d71490>\n\n\u001b[1m    def test_arbitrary_headers_are_passed_on(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\", headers={'Foo': 'Bar'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c0c3d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96ce7e10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96ce7b90>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_headers/test_https.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_X_Forwarded_For_is_generated _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c67b50>\n\n\u001b[1m    def test_X_Forwarded_For_is_generated(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:13: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c67450>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c67f50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96c67a90>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_X_Forwarded_For_is_passed_on _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cb7810>\n\n\u001b[1m    def test_X_Forwarded_For_is_passed_on(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\", headers={'X-Forwarded-For': '1.2.3.4'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cb7790>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96af2590>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96af2450>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_____________________ test_X_Forwarded_Proto_is_generated ______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96ded9d0>\n\n\u001b[1m    def test_X_Forwarded_Proto_is_generated(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96dedf90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96beea90>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96bee390>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_____________________ test_X_Forwarded_Proto_is_passed_on ______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96a93ad0>\n\n\u001b[1m    def test_X_Forwarded_Proto_is_passed_on(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\", headers={'X-Forwarded-Proto': 'f00'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96a93190>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96a93310>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96a934d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_X_Forwarded_Port_is_generated ______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96e846d0>\n\n\u001b[1m    def test_X_Forwarded_Port_is_generated(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96be9e50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96be9bd0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96c606d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_X_Forwarded_Port_is_passed_on ______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96dbd210>\n\n\u001b[1m    def test_X_Forwarded_Port_is_passed_on(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\", headers={'X-Forwarded-Port': '1234'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:44: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96dbd710>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96dbde10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96bd4c90>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_X_Forwarded_Ssl_is_generated _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c06850>\n\n\u001b[1m    def test_X_Forwarded_Ssl_is_generated(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:52: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c062d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96dc43d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96dd6810>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_____________________ test_X_Forwarded_Ssl_is_overwritten ______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bd8250>\n\n\u001b[1m    def test_X_Forwarded_Ssl_is_overwritten(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\", headers={'X-Forwarded-Ssl': 'f00'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bd8c90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bd8110>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96bc9050>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_________________________ test_X_Real_IP_is_generated __________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c0cd10>\n\n\u001b[1m    def test_X_Real_IP_is_generated(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c0c4d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96dc85d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96dc87d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m____________________________ test_Host_is_passed_on ____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c622d0>\n\n\u001b[1m    def test_Host_is_passed_on(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c62510>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c62250>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96c62c10>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________________ test_httpoxy_safe _______________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96e14a10>\n\n\u001b[1m    def test_httpoxy_safe(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m        \"\"\"\u001b[0m\n\u001b[1m        See https://httpoxy.org/\u001b[0m\n\u001b[1m        nginx-proxy should suppress the `Proxy` header\u001b[0m\n\u001b[1m        \"\"\"\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web.nginx-proxy.tld/headers\", headers={'Proxy': 'tcp://some.hacker.com'})\u001b[0m\n\n\u001b[1m\u001b[31mtest_headers/test_https.py\u001b[0m:79: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96e148d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c67e10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web.nginx-proxy.tld', port=443): Max retries exceeded with url: /headers (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96c67350>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:39 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:39 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_headers/test_https.yml down\n\u001b[1m\u001b[31m____________________ test_answer_is_served_from_chosen_port ____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c06190>\n\n\u001b[1m    def test_answer_is_served_from_chosen_port(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_multiple-ports/test_VIRTUAL_PORT.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c0cc90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bae890>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96baed90>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:47 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:47 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:47 Watching docker events\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:47 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:47 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:47 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:47 Received signal: terminated\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_multiple-ports/test_VIRTUAL_PORT.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_multiple-ports/test_VIRTUAL_PORT.yml down\n\u001b[1m\u001b[31m________________ test_answer_is_served_from_port_80_by_default _________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bc4890>\n\n\u001b[1m    def test_answer_is_served_from_port_80_by_default(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_multiple-ports/test_default-80.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cf77d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96dedd50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96b9f850>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:52 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:52 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_multiple-ports/test_default-80.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_multiple-ports/test_default-80.yml down\n\u001b[1m\u001b[31m____________ test_answer_is_served_from_exposed_port_even_if_not_80 ____________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c4c7d0>\n\n\u001b[1m    def test_answer_is_served_from_exposed_port_even_if_not_80(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_multiple-ports/test_single-port-not-80.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96b7b250>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96b7b210>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96b7bcd0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:57 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:57 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:06:57 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:57 Watching docker events\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:57 Received signal: terminated\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:06:57 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_multiple-ports/test_single-port-not-80.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_multiple-ports/test_single-port-not-80.yml down\n\u001b[1m\u001b[31m___________________ test_dhparam_is_not_generated_if_present ___________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\n\n\u001b[1m    def test_dhparam_is_not_generated_if_present(docker_compose):\u001b[0m\n\u001b[1m        sut_container = docker_client.containers.get(\"nginxproxy\")\u001b[0m\n\u001b[1m>       assert sut_container.status == \"running\"\u001b[0m\n\u001b[1m\u001b[31mE       assert 'exited' == 'running'\u001b[0m\n\u001b[1m\u001b[31mE         - exited\u001b[0m\n\u001b[1m\u001b[31mE         + running\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_dhparam.py\u001b[0m:69: AssertionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:03 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:03 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:03 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_dhparam.yml up -d\n\u001b[1m\u001b[31m____________________________ test_web5_https_works _____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96f66210>\n\n\u001b[1m    def test_web5_https_works(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web5.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_dhparam.py\u001b[0m:80: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c44a90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c44350>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web5.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96c44850>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:03 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:03 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:03 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web5.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web5.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web5.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web5.nginx-proxy.tld')\nDEBUG:DNS:'web5.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m__________________________ test_web5_dhparam_is_used ___________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\n\n\u001b[1m    @require_openssl(\"1.0.2\")\u001b[0m\n\u001b[1m    def test_web5_dhparam_is_used(docker_compose):\u001b[0m\n\u001b[1m        sut_container = docker_client.containers.get(\"nginxproxy\")\u001b[0m\n\u001b[1m>       assert sut_container.status == \"running\"\u001b[0m\n\u001b[1m\u001b[31mE       assert 'exited' == 'running'\u001b[0m\n\u001b[1m\u001b[31mE         - exited\u001b[0m\n\u001b[1m\u001b[31mE         + running\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_dhparam.py\u001b[0m:88: AssertionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:03 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:03 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:03 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_dhparam.yml down\n\u001b[1m\u001b[31m_____________________ test_dhparam_is_generated_if_missing _____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\n\n\u001b[1m    def test_dhparam_is_generated_if_missing(docker_compose):\u001b[0m\n\u001b[1m        sut_container = docker_client.containers.get(\"nginxproxy\")\u001b[0m\n\u001b[1m>       assert sut_container.status == \"running\"\u001b[0m\n\u001b[1m\u001b[31mE       assert 'exited' == 'running'\u001b[0m\n\u001b[1m\u001b[31mE         - exited\u001b[0m\n\u001b[1m\u001b[31mE         + running\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_dhparam_generation.py\u001b[0m:36: AssertionError\n------------------------------- nginx-proxy logs -------------------------------\nWARNING: /etc/nginx/dhparam/dhparam.pem was not found. A pre-generated dhparam.pem will be used for now while a new one\nis being generated in the background.  Once the new dhparam.pem is in place, nginx will be reloaded.\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n2019/07/30 08:07:08 [notice] 44#44: signal process started\n2019/07/30 08:07:08 [error] 44#44: open() \"/var/run/nginx.pid\" failed (2: No such file or directory)\nnginx: [error] open() \"/var/run/nginx.pid\" failed (2: No such file or directory)\nGenerating DH parameters, 256 bit long safe prime, generator 2\nThis is going to take a long time\ndhparam generation complete, reloading nginx\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:08 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:08 Generated '/app/htpasswd_generator.sh' from 2 containers\n\u001b[0m\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_dhparam_generation.yml up -d\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_dhparam_generation.yml down\n\u001b[1m\u001b[31m____________________________ test_web1_HSTS_default ____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cf7dd0>\n\n\u001b[1m    def test_web1_HSTS_default(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web1.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_hsts.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96ded6d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96b39e50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web1.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96cd6f50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:14 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_hsts.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.tld')\nDEBUG:DNS:'web1.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_____________________________ test_web1_HSTS_error _____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cbee90>\n\n\u001b[1m    def test_web1_HSTS_error(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web1.nginx-proxy.tld/status/500\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_hsts.py\u001b[0m:13: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96da7e50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96da7190>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web1.nginx-proxy.tld', port=443): Max retries exceeded with url: /status/500 (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96d76390>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:14 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web1.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web1.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web1.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web1.nginx-proxy.tld')\nDEBUG:DNS:'web1.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________________ test_web2_HSTS_off ______________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96f4b8d0>\n\n\u001b[1m    def test_web2_HSTS_off(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web2.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_hsts.py\u001b[0m:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bc0490>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bc0e10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web2.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96b750d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:14 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.tld')\nDEBUG:DNS:'web2.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m____________________________ test_web3_HSTS_custom _____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bbfa50>\n\n\u001b[1m    def test_web3_HSTS_custom(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web3.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_hsts.py\u001b[0m:23: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bbf310>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96af5390>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web3.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96af55d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:14 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web3.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web3.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web3.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web3.nginx-proxy.tld')\nDEBUG:DNS:'web3.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m________________________ test_web4_HSTS_off_noredirect _________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bb2890>\n\n\u001b[1m    def test_web4_HSTS_off_noredirect(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web4.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_hsts.py\u001b[0m:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bc9c10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bc97d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web4.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96bd8850>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:14 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web4.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web4.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web4.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web4.nginx-proxy.tld')\nDEBUG:DNS:'web4.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_hsts.yml down\n\u001b[1m\u001b[31m_______________________ test_web2_http_is_not_forwarded ________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bee050>\n\n\u001b[1m    def test_web2_http_is_not_forwarded(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web2.nginx-proxy.tld/\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_nohttp.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bee7d0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bee9d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web2.nginx-proxy.tld', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96e147d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:21 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:21 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_nohttp.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.tld')\nDEBUG:DNS:'web2.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_________________________ test_web2_https_is_forwarded _________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96da64d0>\n\n\u001b[1m    def test_web2_https_is_forwarded(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web2.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_nohttp.py\u001b[0m:10: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bb3950>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bb37d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web2.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96bd4f50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:21 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:21 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.tld')\nDEBUG:DNS:'web2.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_______________________ test_web2_HSTS_policy_is_active ________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96d01850>\n\n\u001b[1m    def test_web2_HSTS_policy_is_active(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web2.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_nohttp.py\u001b[0m:16: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96d01bd0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96a93910>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web2.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96a93a50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:21 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:21 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web2.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web2.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web2.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web2.nginx-proxy.tld')\nDEBUG:DNS:'web2.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_nohttp.yml down\n\u001b[1m\u001b[31m____________________________ test_http_is_forwarded ____________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c56d10>\n\n\u001b[1m    def test_http_is_forwarded(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_nohttps.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96ba1c90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d90bd0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96d90e10>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:26 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:26 Watching docker events\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:26 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:26 Contents of /app/htpasswd_generator.sh did not change. Skipping notification '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:26 Received signal: terminated\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_nohttps.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web.nginx-proxy.tld')\nDEBUG:DNS:'web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_________________________ test_web3_http_is_forwarded __________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96da6390>\n\n\u001b[1m    def test_web3_http_is_forwarded(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://web3.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_noredirect.py\u001b[0m:5: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c7bdd0>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96df0c50>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='web3.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96984810>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:32 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:32 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_noredirect.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web3.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web3.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web3.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web3.nginx-proxy.tld')\nDEBUG:DNS:'web3.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_________________________ test_web3_https_is_forwarded _________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96984950>\n\n\u001b[1m    def test_web3_https_is_forwarded(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web3.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_noredirect.py\u001b[0m:11: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96984710>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96994790>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web3.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96994090>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:32 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:32 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web3.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web3.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web3.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web3.nginx-proxy.tld')\nDEBUG:DNS:'web3.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_web2_HSTS_policy_is_inactive _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bdbe10>\n\n\u001b[1m    def test_web2_HSTS_policy_is_inactive(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://web3.nginx-proxy.tld/port\", allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_noredirect.py\u001b[0m:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96bdb610>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96b79510>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='web3.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96b79b10>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:32 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:32 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('web3.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('web3.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'web3.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('web3.nginx-proxy.tld')\nDEBUG:DNS:'web3.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_noredirect.yml down\n\u001b[1m\u001b[31m____________________ test_web1_http_redirects_to_https[foo] ____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96bafc10>\nsubdomain = 'foo'\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain\", [\"foo\", \"bar\"])\u001b[0m\n\u001b[1m    def test_web1_http_redirects_to_https(docker_compose, nginxproxy, subdomain):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s.nginx-proxy.tld/\" % subdomain, allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_wildcard.py\u001b[0m:6: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c62650>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c623d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='foo.nginx-proxy.tld', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96b93490>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:37 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_wildcard.yml up -d\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('foo.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('foo.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'foo.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('foo.nginx-proxy.tld')\nDEBUG:DNS:'foo.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m____________________ test_web1_http_redirects_to_https[bar] ____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96da3b90>\nsubdomain = 'bar'\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain\", [\"foo\", \"bar\"])\u001b[0m\n\u001b[1m    def test_web1_http_redirects_to_https(docker_compose, nginxproxy, subdomain):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s.nginx-proxy.tld/\" % subdomain, allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_wildcard.py\u001b[0m:6: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96da3150>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bc01d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='bar.nginx-proxy.tld', port=80): Max retries exceeded with url: / (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96df5510>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:37 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('bar.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('bar.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'bar.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('bar.nginx-proxy.tld')\nDEBUG:DNS:'bar.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_web1_https_is_forwarded[foo] _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cc4c50>\nsubdomain = 'foo'\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain\", [\"foo\", \"bar\"])\u001b[0m\n\u001b[1m    def test_web1_https_is_forwarded(docker_compose, nginxproxy, subdomain):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://%s.nginx-proxy.tld/port\" % subdomain, allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_wildcard.py\u001b[0m:14: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cc4110>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96cf7350>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='foo.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96cf7590>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:37 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('foo.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('foo.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'foo.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('foo.nginx-proxy.tld')\nDEBUG:DNS:'foo.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m______________________ test_web1_https_is_forwarded[bar] _______________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96cf3a50>\nsubdomain = 'bar'\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain\", [\"foo\", \"bar\"])\u001b[0m\n\u001b[1m    def test_web1_https_is_forwarded(docker_compose, nginxproxy, subdomain):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://%s.nginx-proxy.tld/port\" % subdomain, allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_wildcard.py\u001b[0m:14: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96cf3650>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96d97a10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='bar.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96d972d0>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:37 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('bar.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('bar.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'bar.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('bar.nginx-proxy.tld')\nDEBUG:DNS:'bar.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_____________________ test_web1_HSTS_policy_is_active[foo] _____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a9697f190>\nsubdomain = 'foo'\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain\", [\"foo\", \"bar\"])\u001b[0m\n\u001b[1m    def test_web1_HSTS_policy_is_active(docker_compose, nginxproxy, subdomain):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://%s.nginx-proxy.tld/port\" % subdomain, allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_wildcard.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a9697f310>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a9697f5d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='foo.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a9697fd10>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:37 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('foo.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('foo.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'foo.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('foo.nginx-proxy.tld')\nDEBUG:DNS:'foo.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_____________________ test_web1_HSTS_policy_is_active[bar] _____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c4be10>\nsubdomain = 'bar'\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain\", [\"foo\", \"bar\"])\u001b[0m\n\u001b[1m    def test_web1_HSTS_policy_is_active(docker_compose, nginxproxy, subdomain):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://%s.nginx-proxy.tld/port\" % subdomain, allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/test_wildcard.py\u001b[0m:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c4ba50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96b86810>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='bar.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96b86710>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Generated '/app/htpasswd_generator.sh' from 3 containers\n\u001b[0m\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:37 Running '/app/htpasswd_generator.sh'\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:37 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('bar.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('bar.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving 'bar.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('bar.nginx-proxy.tld')\nDEBUG:DNS:'bar.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/test_wildcard.yml down\n\u001b[1m\u001b[31m_____________________ test_http_redirects_to_https[1-True] _____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a969f9050>\nsubdomain = 1, should_redirect_to_https = True\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain,should_redirect_to_https\", [\u001b[0m\n\u001b[1m        (1, True),\u001b[0m\n\u001b[1m        (2, True),\u001b[0m\n\u001b[1m        (3, False),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_http_redirects_to_https(docker_compose, nginxproxy, subdomain, should_redirect_to_https):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s.web.nginx-proxy.tld/port\" % subdomain)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py\u001b[0m:12: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96a87a90>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96a87d90>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='1.web.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96c4c350>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:45 Generated '/app/htpasswd_generator.sh' from 5 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:45 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n---------------------------- Captured stderr setup -----------------------------\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/wildcard_cert_and_nohttps/docker-compose.yml up -d\nINFO:root:Connecting to docker network: wildcardcertandnohttps_default\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('1.web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('1.web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving '1.web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('1.web.nginx-proxy.tld')\nDEBUG:DNS:'1.web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_____________________ test_http_redirects_to_https[2-True] _____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c7ba50>\nsubdomain = 2, should_redirect_to_https = True\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain,should_redirect_to_https\", [\u001b[0m\n\u001b[1m        (1, True),\u001b[0m\n\u001b[1m        (2, True),\u001b[0m\n\u001b[1m        (3, False),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_http_redirects_to_https(docker_compose, nginxproxy, subdomain, should_redirect_to_https):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s.web.nginx-proxy.tld/port\" % subdomain)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py\u001b[0m:12: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c7b190>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96bd4510>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='2.web.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96cd6b50>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:45 Generated '/app/htpasswd_generator.sh' from 5 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:45 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('2.web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('2.web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving '2.web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('2.web.nginx-proxy.tld')\nDEBUG:DNS:'2.web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m____________________ test_http_redirects_to_https[3-False] _____________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96af5210>\nsubdomain = 3, should_redirect_to_https = False\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain,should_redirect_to_https\", [\u001b[0m\n\u001b[1m        (1, True),\u001b[0m\n\u001b[1m        (2, True),\u001b[0m\n\u001b[1m        (3, False),\u001b[0m\n\u001b[1m    ])\u001b[0m\n\u001b[1m    def test_http_redirects_to_https(docker_compose, nginxproxy, subdomain, should_redirect_to_https):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"http://%s.web.nginx-proxy.tld/port\" % subdomain)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py\u001b[0m:12: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96af5b50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96af58d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPConnectionPool(host='3.web.nginx-proxy.tld', port=80): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.HTTPConnection object at 0x7f9a96bbf210>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:45 Generated '/app/htpasswd_generator.sh' from 5 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:45 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('3.web.nginx-proxy.tld', 80, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('3.web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving '3.web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('3.web.nginx-proxy.tld')\nDEBUG:DNS:'3.web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m___________________________ test_https_get_served[1] ___________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96dcb050>\nsubdomain = 1\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain\", [1, 2])\u001b[0m\n\u001b[1m    def test_https_get_served(docker_compose, nginxproxy, subdomain):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://%s.web.nginx-proxy.tld/port\" % subdomain, allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py\u001b[0m:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96dcbe10>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96dcb0d0>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='1.web.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96bcd190>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:45 Generated '/app/htpasswd_generator.sh' from 5 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:45 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('1.web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('1.web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving '1.web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('1.web.nginx-proxy.tld')\nDEBUG:DNS:'1.web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m___________________________ test_https_get_served[2] ___________________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96c062d0>\nsubdomain = 2\n\n\u001b[1m    @pytest.mark.parametrize(\"subdomain\", [1, 2])\u001b[0m\n\u001b[1m    def test_https_get_served(docker_compose, nginxproxy, subdomain):\u001b[0m\n\u001b[1m>       r = nginxproxy.get(\"https://%s.web.nginx-proxy.tld/port\" % subdomain, allow_redirects=False)\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py\u001b[0m:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96c06150>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96983a10>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='2.web.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96983290>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:45 Generated '/app/htpasswd_generator.sh' from 5 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:45 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('2.web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('2.web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving '2.web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('2.web.nginx-proxy.tld')\nDEBUG:DNS:'2.web.nginx-proxy.tld' does not match\n\u001b[1m\u001b[31m_______________ test_web3_https_is_500_and_SSL_validation_fails ________________\u001b[0m\n\ndocker_compose = <docker.client.DockerClient object at 0x7f9a970d3ad0>\nnginxproxy = <conftest.requests_for_docker object at 0x7f9a96e72a50>\n\n\u001b[1m    def test_web3_https_is_500_and_SSL_validation_fails(docker_compose, nginxproxy):\u001b[0m\n\u001b[1m        with pytest.raises( (CertificateError, SSLError) ) as excinfo:\u001b[0m\n\u001b[1m>           nginxproxy.get(\"https://3.web.nginx-proxy.tld/port\")\u001b[0m\n\n\u001b[1m\u001b[31mtest_ssl/wildcard_cert_and_nohttps/test_wildcard_cert_nohttps.py\u001b[0m:29: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\u001b[1m\u001b[31mconftest.py\u001b[0m:83: in get\n\u001b[1m    return _get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/backoff.py\u001b[0m:173: in retry\n\u001b[1m    ret = target(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31mconftest.py\u001b[0m:82: in _get\n\u001b[1m    return self.session.get(*args, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:488: in get\n\u001b[1m    return self.request('GET', url, **kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:475: in request\n\u001b[1m    resp = self.send(prep, **send_kwargs)\u001b[0m\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/sessions.py\u001b[0m:596: in send\n\u001b[1m    r = adapter.send(request, **kwargs)\u001b[0m\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x7f9a96e72e50>\nrequest = <PreparedRequest [GET]>, stream = False\ntimeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7f9a96c67150>\nverify = '/home/travis/build/jwilder/nginx-proxy/test/certs/ca-root.crt'\ncert = None, proxies = OrderedDict()\n\n\u001b[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\u001b[0m\n\u001b[1m        \"\"\"Sends PreparedRequest object. Returns Response object.\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\u001b[0m\n\u001b[1m            :param stream: (optional) Whether to stream the request content.\u001b[0m\n\u001b[1m            :param timeout: (optional) How long to wait for the server to send\u001b[0m\n\u001b[1m                data before giving up, as a float, or a :ref:`(connect timeout,\u001b[0m\n\u001b[1m                read timeout) <timeouts>` tuple.\u001b[0m\n\u001b[1m            :type timeout: float or tuple\u001b[0m\n\u001b[1m            :param verify: (optional) Whether to verify SSL certificates.\u001b[0m\n\u001b[1m            :param cert: (optional) Any user-provided SSL certificate to be trusted.\u001b[0m\n\u001b[1m            :param proxies: (optional) The proxies dictionary to apply to the request.\u001b[0m\n\u001b[1m            :rtype: requests.Response\u001b[0m\n\u001b[1m            \"\"\"\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        conn = self.get_connection(request.url, proxies)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        self.cert_verify(conn, request.url, verify, cert)\u001b[0m\n\u001b[1m        url = self.request_url(request, proxies)\u001b[0m\n\u001b[1m        self.add_headers(request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        if isinstance(timeout, tuple):\u001b[0m\n\u001b[1m            try:\u001b[0m\n\u001b[1m                connect, read = timeout\u001b[0m\n\u001b[1m                timeout = TimeoutSauce(connect=connect, read=read)\u001b[0m\n\u001b[1m            except ValueError as e:\u001b[0m\n\u001b[1m                # this may raise a string formatting error.\u001b[0m\n\u001b[1m                err = (\"Invalid timeout {0}. Pass a (connect, read) \"\u001b[0m\n\u001b[1m                       \"timeout tuple, or a single float to set \"\u001b[0m\n\u001b[1m                       \"both timeouts to the same value\".format(timeout))\u001b[0m\n\u001b[1m                raise ValueError(err)\u001b[0m\n\u001b[1m        else:\u001b[0m\n\u001b[1m            timeout = TimeoutSauce(connect=timeout, read=timeout)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        try:\u001b[0m\n\u001b[1m            if not chunked:\u001b[0m\n\u001b[1m                resp = conn.urlopen(\u001b[0m\n\u001b[1m                    method=request.method,\u001b[0m\n\u001b[1m                    url=url,\u001b[0m\n\u001b[1m                    body=request.body,\u001b[0m\n\u001b[1m                    headers=request.headers,\u001b[0m\n\u001b[1m                    redirect=False,\u001b[0m\n\u001b[1m                    assert_same_host=False,\u001b[0m\n\u001b[1m                    preload_content=False,\u001b[0m\n\u001b[1m                    decode_content=False,\u001b[0m\n\u001b[1m                    retries=self.max_retries,\u001b[0m\n\u001b[1m                    timeout=timeout\u001b[0m\n\u001b[1m                )\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            # Send the request.\u001b[0m\n\u001b[1m            else:\u001b[0m\n\u001b[1m                if hasattr(conn, 'proxy_pool'):\u001b[0m\n\u001b[1m                    conn = conn.proxy_pool\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                try:\u001b[0m\n\u001b[1m                    low_conn.putrequest(request.method,\u001b[0m\n\u001b[1m                                        url,\u001b[0m\n\u001b[1m                                        skip_accept_encoding=True)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for header, value in request.headers.items():\u001b[0m\n\u001b[1m                        low_conn.putheader(header, value)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    low_conn.endheaders()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    for i in request.body:\u001b[0m\n\u001b[1m                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                        low_conn.send(i)\u001b[0m\n\u001b[1m                        low_conn.send(b'\\r\\n')\u001b[0m\n\u001b[1m                    low_conn.send(b'0\\r\\n\\r\\n')\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    # Receive the response from the server\u001b[0m\n\u001b[1m                    try:\u001b[0m\n\u001b[1m                        # For Python 2.7+ versions, use buffering of HTTP\u001b[0m\n\u001b[1m                        # responses\u001b[0m\n\u001b[1m                        r = low_conn.getresponse(buffering=True)\u001b[0m\n\u001b[1m                    except TypeError:\u001b[0m\n\u001b[1m                        # For compatibility with Python 2.6 versions and back\u001b[0m\n\u001b[1m                        r = low_conn.getresponse()\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m                    resp = HTTPResponse.from_httplib(\u001b[0m\n\u001b[1m                        r,\u001b[0m\n\u001b[1m                        pool=conn,\u001b[0m\n\u001b[1m                        connection=low_conn,\u001b[0m\n\u001b[1m                        preload_content=False,\u001b[0m\n\u001b[1m                        decode_content=False\u001b[0m\n\u001b[1m                    )\u001b[0m\n\u001b[1m                except:\u001b[0m\n\u001b[1m                    # If we hit any problems here, clean up the connection.\u001b[0m\n\u001b[1m                    # Then, reraise so that we can handle the actual exception.\u001b[0m\n\u001b[1m                    low_conn.close()\u001b[0m\n\u001b[1m                    raise\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except (ProtocolError, socket.error) as err:\u001b[0m\n\u001b[1m            raise ConnectionError(err, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m        except MaxRetryError as e:\u001b[0m\n\u001b[1m            if isinstance(e.reason, ConnectTimeoutError):\u001b[0m\n\u001b[1m                # TODO: Remove this in 3.0.0: see #2811\u001b[0m\n\u001b[1m                if not isinstance(e.reason, NewConnectionError):\u001b[0m\n\u001b[1m                    raise ConnectTimeout(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, ResponseError):\u001b[0m\n\u001b[1m                raise RetryError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m            if isinstance(e.reason, _ProxyError):\u001b[0m\n\u001b[1m                raise ProxyError(e, request=request)\u001b[0m\n\u001b[1m    \u001b[0m\n\u001b[1m>           raise ConnectionError(e, request=request)\u001b[0m\n\u001b[1m\u001b[31mE           ConnectionError: HTTPSConnectionPool(host='3.web.nginx-proxy.tld', port=443): Max retries exceeded with url: /port (Caused by NewConnectionError('<requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f9a96c67a10>: Failed to establish a new connection: [Errno -2] Name does not resolve',))\u001b[0m\n\n\u001b[1m\u001b[31m/usr/local/lib/python2.7/site-packages/requests/adapters.py\u001b[0m:487: ConnectionError\n------------------------------- nginx-proxy logs -------------------------------\nCustom dhparam.pem file found, generation skipped\n\u001b[0;37;1mforego       | \u001b[0mstarting htpasswdgen.1 on port 5000\n\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5100\n\u001b[0;37;1mforego       | \u001b[0mstarting nginx.1 on port 5300\n\u001b[0;36;1mhtpasswdgen.1 | \u001b[0;31;1m2019/07/30 08:07:45 Generated '/app/htpasswd_generator.sh' from 5 containers\n\u001b[0m\u001b[0;33;1mdockergen.1  | \u001b[0;31;1m2019/07/30 08:07:45 Unable to parse template: template: nginx.tmpl:130: undefined variable \"$container\"\n\u001b[0m\u001b[0;37;1mforego       | \u001b[0mstarting dockergen.1 on port 5400\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to nginx.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to htpasswdgen.1\n\u001b[0;37;1mforego       | \u001b[0msending SIGTERM to dockergen.1\n\n------------------------------- nginx-proxy conf -------------------------------\nserver {\n    listen       80;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http://127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache's document root\n    # concurs with nginx's one\n    #\n    #location ~ /\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n----------------------------- Captured stderr call -----------------------------\nDEBUG:DNS:resolving domain name ('3.web.nginx-proxy.tld', 443, 2, 1)\nDEBUG:DNS:nginx_proxy_dns_resolver('3.web.nginx-proxy.tld')\nWARNING:DNS:no container found from image jwilder/nginx-proxy:test while resolving '3.web.nginx-proxy.tld'\nDEBUG:DNS:docker_container_dns_resolver('3.web.nginx-proxy.tld')\nDEBUG:DNS:'3.web.nginx-proxy.tld' does not match\n--------------------------- Captured stderr teardown ---------------------------\nINFO:root:Disconnecting from network wildcardcertandnohttps_default\nINFO:root:docker-compose -f /home/travis/build/jwilder/nginx-proxy/test/test_ssl/wildcard_cert_and_nohttps/docker-compose.yml down\n\u001b[1m\u001b[31m============== 115 failed, 2 passed, 12 xfailed in 213.12 seconds ==============\u001b[0m\nmake: *** [test-debian] Error 1\ntravis_time:end:0922bd43:start=1564473825728721687,finish=1564474073482769351,duration=247754047664\n\u001b[0K\u001b[31;1mThe command \"make $TEST_TARGET\" exited with 2.\u001b[0m\n\n\n\nDone. Your build exited with 1.\n"
}